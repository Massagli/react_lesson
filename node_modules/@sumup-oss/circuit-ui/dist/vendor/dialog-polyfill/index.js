const dialogPolyfill = {};
if (typeof window === "undefined") {
  let getServerSideThrower = function(name, isProp) {
    let error = "";
    if (isProp) {
      error = `Cannot access property \`dialogPolyfill.${name}\` on the server side.`;
    } else {
      error = `Cannot execute \`dialogPolyfill.${name}()\` on the server side.`;
    }
    return function() {
      throw new Error(error);
    };
  };
  dialogPolyfill.registerDialog = getServerSideThrower("registerDialog");
  dialogPolyfill.forceRegisterDialog = getServerSideThrower(
    "forceRegisterDialog"
  );
  dialogPolyfill.reposition = getServerSideThrower("reposition");
  dialogPolyfill.isInlinePositionSetByStylesheet = getServerSideThrower(
    "isInlinePositionSetByStylesheet"
  );
  dialogPolyfill.needsCentering = getServerSideThrower("needsCentering");
  dialogPolyfill.DialogManager = getServerSideThrower("DialogManager");
  Object.defineProperties(dialogPolyfill, {
    dm: { get: getServerSideThrower("dm", true) },
    formSubmitter: { get: getServerSideThrower("formSubmitter", true) },
    imagemapUseValue: { get: getServerSideThrower("imagemapUseValue", true) }
  });
} else {
  let safeDispatchEvent = function(target, event) {
    const check = `on${event.type.toLowerCase()}`;
    if (typeof target[check] === "function") {
      target[check](event);
    }
    return target.dispatchEvent(event);
  }, createsStackingContext = function(el) {
    while (el && el !== document.body) {
      var s = window.getComputedStyle(el);
      const invalid = function(k, ok) {
        return !(s[k] === void 0 || s[k] === ok);
      };
      if (s.opacity < 1 || invalid("zIndex", "auto") || invalid("transform", "none") || invalid("mixBlendMode", "normal") || invalid("filter", "none") || invalid("perspective", "none") || s.isolation === "isolate" || s.position === "fixed" || s.webkitOverflowScrolling === "touch") {
        return true;
      }
      el = el.parentElement;
    }
    return false;
  }, findNearestDialog = function(el) {
    while (el) {
      if (el.localName === "dialog") {
        return (
          /** @type {HTMLDialogElement} */
          el
        );
      }
      if (el.parentElement) {
        el = el.parentElement;
      } else if (el.parentNode) {
        el = el.parentNode.host;
      } else {
        el = null;
      }
    }
    return null;
  }, safeBlur = function(el) {
    while (el && el.shadowRoot && el.shadowRoot.activeElement) {
      el = el.shadowRoot.activeElement;
    }
    if (el && el.blur && el !== document.body) {
      el.blur();
    }
  }, inNodeList = function(nodeList, node) {
    for (let i = 0; i < nodeList.length; ++i) {
      if (nodeList[i] === node) {
        return true;
      }
    }
    return false;
  }, isFormMethodDialog = function(el) {
    if (!el || !el.hasAttribute("method")) {
      return false;
    }
    return el.getAttribute("method").toLowerCase() === "dialog";
  }, findFocusableElementWithin = function(hostElement) {
    const opts = ["button", "input", "keygen", "select", "textarea"];
    const query = opts.map((el) => `${el}:not([disabled])`);
    query.push('[tabindex]:not([disabled]):not([tabindex=""])');
    let target = hostElement.querySelector(query.join(", "));
    if (!target && "attachShadow" in Element.prototype) {
      const elems = hostElement.querySelectorAll("*");
      for (let i = 0; i < elems.length; i++) {
        if (elems[i].tagName && elems[i].shadowRoot) {
          target = findFocusableElementWithin(elems[i].shadowRoot);
          if (target) {
            break;
          }
        }
      }
    }
    return target;
  }, isConnected = function(element) {
    return element.isConnected || document.body.contains(element);
  }, findFormSubmitter = function(event) {
    if (event.submitter) {
      return event.submitter;
    }
    const form = event.target;
    if (!(form instanceof HTMLFormElement)) {
      return null;
    }
    let submitter = dialogPolyfill.formSubmitter;
    if (!submitter) {
      const { target } = event;
      const root = "getRootNode" in target && target.getRootNode() || document;
      submitter = root.activeElement;
    }
    if (!submitter || submitter.form !== form) {
      return null;
    }
    return submitter;
  }, maybeHandleSubmit = function(event) {
    if (event.defaultPrevented) {
      return;
    }
    const form = (
      /** @type {!HTMLFormElement} */
      event.target
    );
    let value = dialogPolyfill.imagemapUseValue;
    const submitter = findFormSubmitter(event);
    if (value === null && submitter) {
      value = submitter.value;
    }
    const dialog = findNearestDialog(form);
    if (!dialog) {
      return;
    }
    const formmethod = submitter && submitter.getAttribute("formmethod") || form.getAttribute("method");
    if (formmethod !== "dialog") {
      return;
    }
    event.preventDefault();
    if (value != null) {
      dialog.close(value);
    } else {
      dialog.close();
    }
  }, dialogPolyfillInfo = function(dialog) {
    this.dialog_ = dialog;
    this.replacedStyleTop_ = false;
    this.openAsModal_ = false;
    if (!dialog.hasAttribute("role")) {
      dialog.setAttribute("role", "dialog");
    }
    dialog.show = this.show.bind(this);
    dialog.showModal = this.showModal.bind(this);
    dialog.close = this.close.bind(this);
    dialog.addEventListener("submit", maybeHandleSubmit, false);
    if (!("returnValue" in dialog)) {
      dialog.returnValue = "";
    }
    if ("MutationObserver" in window) {
      const mo = new MutationObserver(this.maybeHideModal.bind(this));
      mo.observe(dialog, { attributes: true, attributeFilter: ["open"] });
    } else {
      let removed = false;
      const cb = (function() {
        removed ? this.downgradeModal() : this.maybeHideModal();
        removed = false;
      }).bind(this);
      let timeout;
      const delayModel = function(ev) {
        if (ev.target !== dialog) {
          return;
        }
        const cand = "DOMNodeRemoved";
        removed |= ev.type.substr(0, cand.length) === cand;
        window.clearTimeout(timeout);
        timeout = window.setTimeout(cb, 0);
      };
      [
        "DOMAttrModified",
        "DOMNodeRemoved",
        "DOMNodeRemovedFromDocument"
      ].forEach((name) => {
        dialog.addEventListener(name, delayModel);
      });
    }
    Object.defineProperty(dialog, "open", {
      set: this.setOpen.bind(this),
      get: dialog.hasAttribute.bind(dialog, "open")
    });
    this.backdrop_ = document.createElement("div");
    this.backdrop_.className = "backdrop";
    this.backdrop_.addEventListener(
      "mouseup",
      this.backdropMouseEvent_.bind(this)
    );
    this.backdrop_.addEventListener(
      "mousedown",
      this.backdropMouseEvent_.bind(this)
    );
    this.backdrop_.addEventListener(
      "click",
      this.backdropMouseEvent_.bind(this)
    );
  };
  let supportCustomEvent = window.CustomEvent;
  if (!supportCustomEvent || typeof supportCustomEvent === "object") {
    supportCustomEvent = function CustomEvent(event, x) {
      x = x || {};
      const ev = document.createEvent("CustomEvent");
      ev.initCustomEvent(event, !!x.bubbles, !!x.cancelable, x.detail || null);
      return ev;
    };
    supportCustomEvent.prototype = window.Event.prototype;
  }
  dialogPolyfillInfo.prototype = /** @type {HTMLDialogElement.prototype} */
  {
    get dialog() {
      return this.dialog_;
    },
    /**
     * Maybe remove this dialog from the modal top layer. This is called when
     * a modal dialog may no longer be tenable, e.g., when the dialog is no
     * longer open or is no longer part of the DOM.
     */
    maybeHideModal() {
      if (this.dialog_.hasAttribute("open") && isConnected(this.dialog_)) {
        return;
      }
      this.downgradeModal();
    },
    /**
     * Remove this dialog from the modal top layer, leaving it as a non-modal.
     */
    downgradeModal() {
      if (!this.openAsModal_) {
        return;
      }
      this.openAsModal_ = false;
      this.dialog_.style.zIndex = "";
      if (this.replacedStyleTop_) {
        this.dialog_.style.top = "";
        this.replacedStyleTop_ = false;
      }
      this.backdrop_.parentNode && this.backdrop_.parentNode.removeChild(this.backdrop_);
      dialogPolyfill.dm.removeDialog(this);
    },
    /**
     * @param {boolean} value whether to open or close this dialog
     */
    setOpen(value) {
      if (value) {
        this.dialog_.hasAttribute("open") || this.dialog_.setAttribute("open", "");
      } else {
        this.dialog_.removeAttribute("open");
        this.maybeHideModal();
      }
    },
    /**
     * Handles mouse events ('mouseup', 'mousedown', 'click') on the fake .backdrop element, redirecting them as if
     * they were on the dialog itself.
     *
     * @param {!Event} e to redirect
     */
    backdropMouseEvent_(e) {
      if (!this.dialog_.hasAttribute("tabindex")) {
        const fake = document.createElement("div");
        this.dialog_.insertBefore(fake, this.dialog_.firstChild);
        fake.tabIndex = -1;
        fake.focus();
        this.dialog_.removeChild(fake);
      } else {
        this.dialog_.focus();
      }
      const redirectedEvent = document.createEvent("MouseEvents");
      redirectedEvent.initMouseEvent(
        e.type,
        e.bubbles,
        e.cancelable,
        window,
        e.detail,
        e.screenX,
        e.screenY,
        e.clientX,
        e.clientY,
        e.ctrlKey,
        e.altKey,
        e.shiftKey,
        e.metaKey,
        e.button,
        e.relatedTarget
      );
      this.dialog_.dispatchEvent(redirectedEvent);
      e.stopPropagation();
    },
    /**
     * Focuses on the first focusable element within the dialog. This will always blur the current
     * focus, even if nothing within the dialog is found.
     */
    focus_() {
      let target = this.dialog_.querySelector("[autofocus]:not([disabled])");
      if (!target && this.dialog_.tabIndex >= 0) {
        target = this.dialog_;
      }
      if (!target) {
        target = findFocusableElementWithin(this.dialog_);
      }
      safeBlur(document.activeElement);
      target && target.focus();
    },
    /**
     * Sets the zIndex for the backdrop and dialog.
     *
     * @param {number} dialogZ
     * @param {number} backdropZ
     */
    updateZIndex(dialogZ, backdropZ) {
      if (dialogZ < backdropZ) {
        throw new Error("dialogZ should never be < backdropZ");
      }
      this.dialog_.style.zIndex = dialogZ;
      this.backdrop_.style.zIndex = backdropZ;
    },
    /**
     * Shows the dialog. If the dialog is already open, this does nothing.
     */
    show() {
      if (!this.dialog_.open) {
        this.setOpen(true);
        this.focus_();
      }
    },
    /**
     * Show this dialog modally.
     */
    showModal() {
      if (this.dialog_.hasAttribute("open")) {
        throw new Error(
          "Failed to execute 'showModal' on dialog: The element is already open, and therefore cannot be opened modally."
        );
      }
      if (!isConnected(this.dialog_)) {
        throw new Error(
          "Failed to execute 'showModal' on dialog: The element is not in a Document."
        );
      }
      if (!dialogPolyfill.dm.pushDialog(this)) {
        throw new Error(
          "Failed to execute 'showModal' on dialog: There are too many open modal dialogs."
        );
      }
      if (createsStackingContext(this.dialog_.parentElement)) {
        console.warn(
          "A dialog is being shown inside a stacking context. This may cause it to be unusable. For more information, see this link: https://github.com/GoogleChrome/dialog-polyfill/#stacking-context"
        );
      }
      this.setOpen(true);
      this.openAsModal_ = true;
      if (dialogPolyfill.needsCentering(this.dialog_)) {
        dialogPolyfill.reposition(this.dialog_);
        this.replacedStyleTop_ = true;
      } else {
        this.replacedStyleTop_ = false;
      }
      this.dialog_.parentNode.insertBefore(
        this.backdrop_,
        this.dialog_.nextSibling
      );
      this.focus_();
    },
    /**
     * Closes this HTMLDialogElement. This is optional vs clearing the open
     * attribute, however this fires a 'close' event.
     *
     * @param {string=} opt_returnValue to use as the returnValue
     */
    close(opt_returnValue) {
      if (!this.dialog_.hasAttribute("open")) {
        throw new Error(
          "Failed to execute 'close' on dialog: The element does not have an 'open' attribute, and therefore cannot be closed."
        );
      }
      this.setOpen(false);
      if (opt_returnValue !== void 0) {
        this.dialog_.returnValue = opt_returnValue;
      }
      const closeEvent = new supportCustomEvent("close", {
        bubbles: false,
        cancelable: false
      });
      safeDispatchEvent(this.dialog_, closeEvent);
    }
  };
  dialogPolyfill.reposition = function(element) {
    const scrollTop = document.body.scrollTop || document.documentElement.scrollTop;
    const topValue = scrollTop + (window.innerHeight - element.offsetHeight) / 2;
    element.style.top = `${Math.max(scrollTop, topValue)}px`;
  };
  dialogPolyfill.isInlinePositionSetByStylesheet = function(element) {
    for (let i = 0; i < document.styleSheets.length; ++i) {
      const styleSheet = document.styleSheets[i];
      let cssRules = null;
      try {
        cssRules = styleSheet.cssRules;
      } catch (e) {
      }
      if (!cssRules) {
        continue;
      }
      for (let j = 0; j < cssRules.length; ++j) {
        const rule = cssRules[j];
        let selectedNodes = null;
        try {
          selectedNodes = document.querySelectorAll(rule.selectorText);
        } catch (e) {
        }
        if (!selectedNodes || !inNodeList(selectedNodes, element)) {
          continue;
        }
        const cssTop = rule.style.getPropertyValue("top");
        const cssBottom = rule.style.getPropertyValue("bottom");
        if (cssTop && cssTop !== "auto" || cssBottom && cssBottom !== "auto") {
          return true;
        }
      }
    }
    return false;
  };
  dialogPolyfill.needsCentering = function(dialog) {
    const computedStyle = window.getComputedStyle(dialog);
    if (computedStyle.position !== "absolute") {
      return false;
    }
    if (dialog.style.top !== "auto" && dialog.style.top !== "" || dialog.style.bottom !== "auto" && dialog.style.bottom !== "") {
      return false;
    }
    return !dialogPolyfill.isInlinePositionSetByStylesheet(dialog);
  };
  dialogPolyfill.forceRegisterDialog = function(element) {
    if (window.HTMLDialogElement && window.HTMLDialogElement.prototype.showModal || element.showModal) {
      console.warn(
        "This browser already supports <dialog>, the polyfill may not work correctly",
        element
      );
    }
    if (element.localName !== "dialog") {
      throw new Error(
        "Failed to register dialog: The element is not a dialog."
      );
    }
    new dialogPolyfillInfo(
      /** @type {!HTMLDialogElement} */
      element
    );
  };
  dialogPolyfill.registerDialog = function(element) {
    if (!element.showModal) {
      dialogPolyfill.forceRegisterDialog(element);
    }
  };
  dialogPolyfill.DialogManager = function() {
    this.pendingDialogStack = [];
    const checkDOM = this.checkDOM_.bind(this);
    this.overlay = document.createElement("div");
    this.overlay.className = "_dialog_overlay";
    this.overlay.addEventListener("click", (e) => {
      this.forwardTab_ = void 0;
      e.stopPropagation();
      checkDOM([]);
    });
    this.handleKey_ = this.handleKey_.bind(this);
    this.handleFocus_ = this.handleFocus_.bind(this);
    this.zIndexLow_ = 1e5;
    this.zIndexHigh_ = 1e5 + 150;
    this.forwardTab_ = void 0;
    if ("MutationObserver" in window) {
      this.mo_ = new MutationObserver((records) => {
        let removed = [];
        records.forEach((rec) => {
          for (var i = 0, c; c = rec.removedNodes[i]; ++i) {
            if (!(c instanceof Element)) {
              continue;
            } else if (c.localName === "dialog") {
              removed.push(c);
            }
            removed = removed.concat(c.querySelectorAll("dialog"));
          }
        });
        removed.length && checkDOM(removed);
      });
    }
  };
  dialogPolyfill.DialogManager.prototype.blockDocument = function() {
    document.documentElement.addEventListener("focus", this.handleFocus_, true);
    document.addEventListener("keydown", this.handleKey_);
    this.mo_ && this.mo_.observe(document, { childList: true, subtree: true });
  };
  dialogPolyfill.DialogManager.prototype.unblockDocument = function() {
    document.documentElement.removeEventListener(
      "focus",
      this.handleFocus_,
      true
    );
    document.removeEventListener("keydown", this.handleKey_);
    this.mo_ && this.mo_.disconnect();
  };
  dialogPolyfill.DialogManager.prototype.updateStacking = function() {
    let zIndex = this.zIndexHigh_;
    for (var i = 0, dpi; dpi = this.pendingDialogStack[i]; ++i) {
      dpi.updateZIndex(--zIndex, --zIndex);
      if (i === 0) {
        this.overlay.style.zIndex = --zIndex;
      }
    }
    const last = this.pendingDialogStack[0];
    if (last) {
      const p = last.dialog.parentNode || document.body;
      p.appendChild(this.overlay);
    } else if (this.overlay.parentNode) {
      this.overlay.parentNode.removeChild(this.overlay);
    }
  };
  dialogPolyfill.DialogManager.prototype.containedByTopDialog_ = function(candidate) {
    while (candidate = findNearestDialog(candidate)) {
      for (var i = 0, dpi; dpi = this.pendingDialogStack[i]; ++i) {
        if (dpi.dialog === candidate) {
          return i === 0;
        }
      }
      candidate = candidate.parentElement;
    }
    return false;
  };
  dialogPolyfill.DialogManager.prototype.handleFocus_ = function(event) {
    const target = event.composedPath ? event.composedPath()[0] : event.target;
    if (this.containedByTopDialog_(target)) {
      return;
    }
    if (document.activeElement === document.documentElement) {
      return;
    }
    event.preventDefault();
    event.stopPropagation();
    safeBlur(
      /** @type {Element} */
      target
    );
    if (this.forwardTab_ === void 0) {
      return;
    }
    const dpi = this.pendingDialogStack[0];
    const { dialog } = dpi;
    const position = dialog.compareDocumentPosition(target);
    if (position & Node.DOCUMENT_POSITION_PRECEDING) {
      if (this.forwardTab_) {
        dpi.focus_();
      } else if (target !== document.documentElement) {
        document.documentElement.focus();
      }
    }
    return false;
  };
  dialogPolyfill.DialogManager.prototype.handleKey_ = function(event) {
    this.forwardTab_ = void 0;
    if (event.keyCode === 27) {
      event.preventDefault();
      event.stopPropagation();
      const cancelEvent = new supportCustomEvent("cancel", {
        bubbles: false,
        cancelable: true
      });
      const dpi = this.pendingDialogStack[0];
      if (dpi && safeDispatchEvent(dpi.dialog, cancelEvent)) {
        dpi.dialog.close();
      }
    } else if (event.keyCode === 9) {
      this.forwardTab_ = !event.shiftKey;
    }
  };
  dialogPolyfill.DialogManager.prototype.checkDOM_ = function(removed) {
    const clone = this.pendingDialogStack.slice();
    clone.forEach((dpi) => {
      if (removed.indexOf(dpi.dialog) !== -1) {
        dpi.downgradeModal();
      } else {
        dpi.maybeHideModal();
      }
    });
  };
  dialogPolyfill.DialogManager.prototype.pushDialog = function(dpi) {
    const allowed = (this.zIndexHigh_ - this.zIndexLow_) / 2 - 1;
    if (this.pendingDialogStack.length >= allowed) {
      return false;
    }
    if (this.pendingDialogStack.unshift(dpi) === 1) {
      this.blockDocument();
    }
    this.updateStacking();
    return true;
  };
  dialogPolyfill.DialogManager.prototype.removeDialog = function(dpi) {
    const index = this.pendingDialogStack.indexOf(dpi);
    if (index === -1) {
      return;
    }
    this.pendingDialogStack.splice(index, 1);
    if (this.pendingDialogStack.length === 0) {
      this.unblockDocument();
    }
    this.updateStacking();
  };
  dialogPolyfill.dm = new dialogPolyfill.DialogManager();
  dialogPolyfill.formSubmitter = null;
  dialogPolyfill.imagemapUseValue = null;
  if (window.HTMLDialogElement === void 0) {
    const testForm = document.createElement("form");
    testForm.setAttribute("method", "dialog");
    if (testForm.method !== "dialog") {
      const methodDescriptor = Object.getOwnPropertyDescriptor(
        HTMLFormElement.prototype,
        "method"
      );
      if (methodDescriptor) {
        const realGet = methodDescriptor.get;
        methodDescriptor.get = function() {
          if (isFormMethodDialog(this)) {
            return "dialog";
          }
          return realGet.call(this);
        };
        const realSet = methodDescriptor.set;
        methodDescriptor.set = function(v) {
          if (typeof v === "string" && v.toLowerCase() === "dialog") {
            return this.setAttribute("method", v);
          }
          return realSet.call(this, v);
        };
        Object.defineProperty(
          HTMLFormElement.prototype,
          "method",
          methodDescriptor
        );
      }
    }
    document.addEventListener(
      "click",
      (ev) => {
        dialogPolyfill.formSubmitter = null;
        dialogPolyfill.imagemapUseValue = null;
        if (ev.defaultPrevented) {
          return;
        }
        let target = (
          /** @type {Element} */
          ev.target
        );
        if ("composedPath" in ev) {
          const path = ev.composedPath();
          target = path.shift() || target;
        }
        if (!target || !isFormMethodDialog(target.form)) {
          return;
        }
        const valid = target.type === "submit" && ["button", "input"].indexOf(target.localName) > -1;
        if (!valid) {
          if (!(target.localName === "input" && target.type === "image")) {
            return;
          }
          dialogPolyfill.imagemapUseValue = `${ev.offsetX},${ev.offsetY}`;
        }
        const dialog = findNearestDialog(target);
        if (!dialog) {
          return;
        }
        dialogPolyfill.formSubmitter = target;
      },
      false
    );
    document.addEventListener("submit", (ev) => {
      const form = ev.target;
      const dialog = findNearestDialog(form);
      if (dialog) {
        return;
      }
      const submitter = findFormSubmitter(ev);
      const formmethod = submitter && submitter.getAttribute("formmethod") || form.getAttribute("method");
      if (formmethod === "dialog") {
        ev.preventDefault();
      }
    });
    const nativeFormSubmit = HTMLFormElement.prototype.submit;
    const replacementFormSubmit = function() {
      if (!isFormMethodDialog(this)) {
        return nativeFormSubmit.call(this);
      }
      const dialog = findNearestDialog(this);
      dialog && dialog.close();
    };
    HTMLFormElement.prototype.submit = replacementFormSubmit;
  }
}
export {
  dialogPolyfill as default
};
