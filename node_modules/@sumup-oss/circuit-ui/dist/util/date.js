"use strict";
import { Temporal } from "temporal-polyfill";
import { formatDateTime } from "@sumup-oss/intl";
const MIN_YEAR = 1;
const MAX_YEAR = 9999;
const MIN_MONTH = 1;
const MAX_MONTH = 12;
const MIN_DAY = 1;
function getTodaysDate() {
  return Temporal.Now.plainDateISO();
}
function isPlainDate(date) {
  return date instanceof Temporal.PlainDate;
}
function toPlainDate(date) {
  if (!date) {
    return void 0;
  }
  try {
    return Temporal.PlainDate.from(date);
  } catch {
    return void 0;
  }
}
function clampDate(date, minDate, maxDate) {
  if (minDate && Temporal.PlainDate.compare(date, minDate) < 0) {
    return minDate;
  }
  if (maxDate && Temporal.PlainDate.compare(date, maxDate) > 0) {
    return maxDate;
  }
  return date;
}
function updatePlainDateRange(previousRange, date) {
  if (
    // Nothing selected yet
    !previousRange.start && !previousRange.end || // Full range already selected
    previousRange.start && previousRange.end || // Selected date is before previous start date
    Temporal.PlainDate.compare(previousRange.start, date) > 0
  ) {
    return { start: date, end: void 0 };
  }
  return { start: previousRange.start, end: date };
}
function getFirstDateOfWeek(date, firstDayOfWeek) {
  const diff = (date.dayOfWeek < firstDayOfWeek ? date.daysInWeek : 0) + date.dayOfWeek - firstDayOfWeek;
  return date.subtract({ days: diff });
}
function getLastDateOfWeek(date, firstDayOfWeek) {
  return getFirstDateOfWeek(date, firstDayOfWeek).add({
    days: date.daysInWeek - 1
  });
}
function getMonthName(month, locale) {
  const yearMonth = new Temporal.PlainYearMonth(2e3, month, "gregory");
  return formatDateTime(yearMonth, locale, { month: "long" });
}
export {
  MAX_MONTH,
  MAX_YEAR,
  MIN_DAY,
  MIN_MONTH,
  MIN_YEAR,
  clampDate,
  getFirstDateOfWeek,
  getLastDateOfWeek,
  getMonthName,
  getTodaysDate,
  isPlainDate,
  toPlainDate,
  updatePlainDateRange
};
