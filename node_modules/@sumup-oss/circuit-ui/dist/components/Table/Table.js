"use strict";
"use client";
import { jsx, jsxs } from "react/jsx-runtime";
import { Component, createRef } from "react";
import { isNil } from "../../util/type-check.js";
import { throttle } from "../../util/helpers.js";
import { clsx } from "../../styles/clsx.js";
import { getSortDirection, defaultSortBy } from "./utils.js";
import classes from "./Table.module.css.js";
import { TableHead } from "./components/TableHead/TableHead.js";
import { TableBody } from "./components/TableBody/TableBody.js";
class Table extends Component {
  constructor(props) {
    super(props);
    this.tableRef = createRef();
    this.addVerticalScroll = () => {
      this.calculateTableBodyHeight();
      window.addEventListener(
        "resize",
        throttle(this.calculateTableBodyHeight, 1e3)
      );
    };
    this.removeVerticalScroll = () => {
      window.removeEventListener("resize", this.calculateTableBodyHeight);
    };
    this.calculateTableBodyHeight = () => {
      this.setState({
        tableBodyHeight: isNil(this.tableRef.current) || isNil(this.tableRef.current.parentElement) ? "unset" : `${this.tableRef.current.parentElement.offsetHeight}px`
      });
    };
    this.onSortEnter = (i) => this.setState({ sortHover: i });
    this.onSortLeave = () => this.setState({ sortHover: void 0 });
    this.onSortBy = (i) => {
      const { sortedColumn, sortDirection } = this.state;
      const isActive = i === sortedColumn;
      const nextDirection = getSortDirection(isActive, sortDirection);
      const sortedRows = this.getSortedRows(nextDirection, i);
      this.updateSort(i, nextDirection, sortedRows);
    };
    this.getInitialRows = (rows, initialSortDirection, initialSortedColumn) => initialSortedColumn && initialSortDirection ? this.getSortedRows(initialSortDirection, initialSortedColumn) : rows;
    this.getSortedRows = (sortDirection, sortedRow) => {
      const { rows, onSortBy } = this.props;
      return onSortBy ? onSortBy(sortedRow, rows, sortDirection) : defaultSortBy(sortedRow, rows, sortDirection);
    };
    this.updateSort = (i, nextDirection, sortedRows) => this.setState({
      sortedColumn: i,
      sortDirection: nextDirection,
      rows: sortedRows
    });
    this.handleScroll = (e) => {
      this.setState({ scrollTop: e.currentTarget.scrollTop });
    };
    this.state = {
      sortedColumn: this.props.initialSortedColumn,
      rows: this.getInitialRows(
        this.props.rows,
        this.props.initialSortDirection,
        this.props.initialSortedColumn
      ),
      sortHover: void 0,
      sortDirection: this.props.initialSortDirection,
      scrollTop: void 0,
      tableBodyHeight: void 0
    };
  }
  componentDidMount() {
    if (this.props.scrollable) {
      this.addVerticalScroll();
    }
  }
  componentDidUpdate(prevProps) {
    if (this.props.rows !== prevProps.rows) {
      if (this.state.sortedColumn && this.state.sortDirection) {
        const sortedRows = this.getSortedRows(
          this.state.sortDirection,
          this.state.sortedColumn
        );
        this.setState({ rows: sortedRows });
        return;
      }
      this.setState({ rows: this.props.rows });
    }
    if (!prevProps.scrollable && this.props.scrollable) {
      this.addVerticalScroll();
    }
    if (prevProps.scrollable && !this.props.scrollable) {
      this.removeVerticalScroll();
    }
  }
  componentWillUnmount() {
    if (this.props.scrollable) {
      this.removeVerticalScroll();
    }
  }
  render() {
    const {
      rowHeaders = true,
      headers = [],
      noShadow = false,
      borderCollapsed = false,
      condensed = false,
      scrollable = false,
      onRowClick,
      rows: initialRows,
      initialSortedColumn,
      initialSortDirection,
      onSortBy,
      className,
      ...props
    } = this.props;
    const {
      sortDirection,
      sortHover,
      sortedColumn,
      scrollTop,
      tableBodyHeight,
      rows
    } = this.state;
    return /* @__PURE__ */ jsx(
      "div",
      {
        className: clsx(
          classes.container,
          scrollable && classes.scrollable,
          !noShadow && classes.border,
          className
        ),
        ref: this.tableRef,
        ...props,
        children: /* @__PURE__ */ jsx(
          "div",
          {
            className: clsx(
              classes["scroll-container"],
              rowHeaders && classes["row-headers"]
            ),
            style: { "--table-height": tableBodyHeight || "100%" },
            onScroll: scrollable ? this.handleScroll : void 0,
            children: /* @__PURE__ */ jsxs(
              "table",
              {
                className: clsx(
                  classes.base,
                  borderCollapsed && classes["border-collapse"]
                ),
                children: [
                  /* @__PURE__ */ jsx(
                    TableHead,
                    {
                      top: scrollTop,
                      condensed,
                      scrollable,
                      sortDirection,
                      sortedColumn,
                      onSortBy: this.onSortBy,
                      onSortEnter: this.onSortEnter,
                      onSortLeave: this.onSortLeave,
                      headers,
                      rowHeaders
                    }
                  ),
                  /* @__PURE__ */ jsx(
                    TableBody,
                    {
                      condensed,
                      rows,
                      rowHeaders,
                      sortHover,
                      onRowClick
                    }
                  )
                ]
              }
            )
          }
        )
      }
    );
  }
}
export {
  Table
};
