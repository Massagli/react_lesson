"use strict";
"use client";
import { jsxs, jsx } from "react/jsx-runtime";
import { useState, useCallback, useMemo, createContext, createElement } from "react";
import ReactModal from "react-modal";
import { warn } from "../../util/logger.js";
import { promisify } from "../../util/promises.js";
import { clsx } from "../../styles/clsx.js";
import { useLatest } from "../../hooks/useLatest/useLatest.js";
import { SidePanel } from "./SidePanel.js";
import { TRANSITION_DURATION } from "./constants.js";
import classes from "./SidePanelContext.module.css.js";
import { useMedia } from "../../hooks/useMedia/useMedia.js";
import { useStack } from "../../hooks/useStack/useStack.js";
if (typeof window !== "undefined") {
  const appElement = document.getElementById("__next") || document.getElementById("__docusaurus") || document.getElementById("root") || document.getElementById("storybook-root");
  if (appElement) {
    ReactModal.setAppElement(appElement);
  } else if (process.env.NODE_ENV !== "production" && process.env.NODE_ENV !== "test") {
    warn(
      "SidePanelProvider",
      "Could not find the app root element to hide it when a side panel is open.",
      "Add an element with the id `#root` at the root of your application."
    );
  }
}
const SidePanelContext = createContext({
  setSidePanel: () => {
  },
  updateSidePanel: () => {
  },
  removeSidePanel: () => Promise.resolve(),
  isPrimaryContentResized: false,
  transitionDuration: TRANSITION_DURATION
});
function SidePanelProvider({
  children,
  ...props
}) {
  const isMobile = useMedia("(max-width: 767px)");
  const [sidePanels, dispatch] = useStack();
  const [isPrimaryContentResized, setIsPrimaryContentResized] = useState(false);
  const sidePanelsRef = useLatest(sidePanels);
  const findSidePanel = useCallback(
    (group) => sidePanelsRef.current.find(
      (panel) => panel.group === group && !panel.transition
    ),
    [sidePanelsRef]
  );
  const removeSidePanel = useCallback(
    async (group, isInstantClose) => {
      const panel = findSidePanel(group);
      if (!panel) {
        return;
      }
      const sidePanelIndex = sidePanelsRef.current.indexOf(panel);
      const sidePanelsToRemove = sidePanelsRef.current.slice(sidePanelIndex).reverse();
      for (let index = 0; index < sidePanelsToRemove.length; index += 1) {
        try {
          const sidePanel = sidePanelsToRemove[index];
          if (sidePanel.onClose) {
            await promisify(sidePanel.onClose);
          }
          if (!isInstantClose) {
            setIsPrimaryContentResized(sidePanelIndex !== 0);
          }
          await new Promise((resolve) => {
            const lastPanel = index === sidePanelsToRemove.length - 1;
            if (lastPanel) {
              sidePanel.onAfterClose = resolve;
            } else {
              resolve();
            }
            if (isInstantClose) {
              sidePanel.shouldReturnFocusAfterClose = false;
              sidePanel.closeTimeoutMS = 0;
            }
            dispatch({
              type: "update",
              item: sidePanel
            });
            dispatch({
              type: "remove",
              id: sidePanel.id,
              transition: {
                duration: isInstantClose ? 0 : TRANSITION_DURATION
              }
            });
          });
        } catch (_error) {
          break;
        }
      }
    },
    [findSidePanel, dispatch, sidePanelsRef]
  );
  const setSidePanel = useCallback(
    (sidePanel) => {
      const panel = findSidePanel(sidePanel.group);
      const pushPanel = (isInstantOpen) => {
        setIsPrimaryContentResized(true);
        dispatch({
          type: "push",
          item: { ...sidePanel, isInstantOpen }
        });
      };
      if (panel) {
        removeSidePanel(panel.group, true).then(() => pushPanel(true)).catch(() => {
        });
      } else {
        pushPanel(false);
      }
    },
    [findSidePanel, dispatch, removeSidePanel]
  );
  const updateSidePanel = useCallback(
    (sidePanel) => {
      const panel = findSidePanel(sidePanel.group);
      if (panel) {
        dispatch({
          type: "update",
          item: { ...sidePanel, id: panel.id }
        });
      }
    },
    [findSidePanel, dispatch]
  );
  const context = useMemo(
    () => ({
      setSidePanel,
      updateSidePanel,
      removeSidePanel,
      isPrimaryContentResized: !isMobile && isPrimaryContentResized,
      transitionDuration: TRANSITION_DURATION
    }),
    [
      setSidePanel,
      updateSidePanel,
      removeSidePanel,
      isMobile,
      isPrimaryContentResized
    ]
  );
  return /* @__PURE__ */ jsxs(SidePanelContext.Provider, { value: context, children: [
    /* @__PURE__ */ jsx(
      "div",
      {
        ...props,
        className: clsx(
          classes.base,
          !isMobile && isPrimaryContentResized && classes.resized,
          props.className
        ),
        children
      }
    ),
    sidePanels.map((sidePanel) => {
      const { group, id, transition, ...sidePanelProps } = sidePanel;
      const isBottomPanelClosing = !!sidePanels[0].transition;
      const isStacked = group !== sidePanels[0].group;
      const handleClose = () => {
        void removeSidePanel(sidePanels[0].group);
      };
      const handleBack = isStacked ? () => removeSidePanel(group) : void 0;
      return /* @__PURE__ */ createElement(
        SidePanel,
        {
          ...sidePanelProps,
          key: id,
          isBottomPanelClosing,
          isMobile,
          isOpen: !transition,
          isStacked,
          onBack: handleBack,
          onClose: handleClose,
          portalClassName: classes.portal,
          htmlOpenClassName: classes.open
        }
      );
    })
  ] });
}
export {
  SidePanelContext,
  SidePanelProvider
};
