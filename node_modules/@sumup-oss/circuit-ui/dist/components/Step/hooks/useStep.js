"use strict";
import { useReducer, useRef, useEffect } from "react";
import { CircuitError } from "../../../util/errors.js";
import { isFunction } from "../../../util/type-check.js";
import { calculatePreviousStep, reducer, calculateNextStep, generatePropGetters } from "../StepService.js";
function useStep({
  initialStep = 0,
  totalSteps = 0,
  autoPlay = false,
  cycle = false,
  stepInterval = 1,
  animationDuration = 0,
  stepDuration = 0,
  onNext,
  onPrevious,
  onPause,
  onPlay
} = {}) {
  if (process.env.NODE_ENV !== "production" && cycle && !totalSteps) {
    throw new CircuitError(
      "useStep",
      "Cannot use `cycle` prop without `totalSteps` prop."
    );
  }
  if (process.env.NODE_ENV !== "production" && autoPlay && !stepDuration) {
    throw new CircuitError(
      "useStep",
      "Cannot use `autoPlay` prop without `stepDuration` prop."
    );
  }
  const initialState = {
    step: initialStep,
    previousStep: calculatePreviousStep({
      step: initialStep,
      totalSteps,
      stepInterval,
      cycle
    }),
    paused: !autoPlay
  };
  const [state, dispatch] = useReducer(reducer, initialState);
  const playingInterval = useRef(null);
  const animationEndCallback = useRef(
    null
  );
  useEffect(() => {
    const playable = shouldPlay();
    const finished = shouldStop();
    if (playable && !finished) {
      startPlaying();
    }
    return function cleanup() {
      stopPlaying();
    };
  });
  function next() {
    const newStep = calculateNextStep({
      step: state.step,
      stepInterval,
      totalSteps,
      cycle
    });
    updateSlide(newStep, () => {
      if (isFunction(onNext)) {
        onNext(getStateAndHelpers());
      }
    });
  }
  function previous() {
    const newStep = calculatePreviousStep({
      step: state.step,
      stepInterval,
      totalSteps,
      cycle
    });
    updateSlide(newStep, () => {
      if (isFunction(onPrevious)) {
        onPrevious(getStateAndHelpers());
      }
    });
  }
  function pause() {
    updatePause(true);
    if (isFunction(onPause)) {
      onPause(getStateAndHelpers());
    }
  }
  function play() {
    updatePause(false);
    if (isFunction(onPlay)) {
      onPlay(getStateAndHelpers());
    }
  }
  function shouldPlay() {
    const duration = getDurationFromProp(stepDuration);
    return duration && !state.paused;
  }
  function shouldStop() {
    const isLastStep = state.step === totalSteps - 1;
    const duration = getDurationFromProp(stepDuration);
    return duration && !cycle && isLastStep;
  }
  function getDurationFromProp(duration) {
    return isFunction(duration) ? duration(state.step) : duration;
  }
  function startPlaying() {
    if (!playingInterval.current) {
      playingInterval.current = setInterval(
        next,
        getDurationFromProp(stepDuration)
      );
    }
  }
  function stopPlaying() {
    if (playingInterval.current) {
      clearInterval(playingInterval.current);
      playingInterval.current = null;
    }
  }
  function updateSlide(newStep, onEndCallback) {
    const duration = getDurationFromProp(animationDuration);
    const update = () => {
      if (animationEndCallback.current) {
        clearTimeout(animationEndCallback.current);
        animationEndCallback.current = null;
      }
      stopPlaying();
      dispatch({
        type: "updateSlide",
        payload: {
          step: newStep,
          previousStep: state.step
        }
      });
      onEndCallback();
    };
    if (duration) {
      animationEndCallback.current = setTimeout(update, duration);
    } else {
      update();
    }
  }
  function updatePause(paused) {
    const duration = getDurationFromProp(stepDuration);
    if (!duration) {
      return;
    }
    dispatch({
      type: "updatePause",
      payload: { paused }
    });
    if (paused) {
      stopPlaying();
    } else {
      startPlaying();
    }
  }
  function getStateAndHelpers() {
    const actions = {
      next,
      previous,
      play,
      pause
    };
    const propGetters = generatePropGetters(actions);
    return {
      state: {
        ...state,
        stepDuration: getDurationFromProp(stepDuration),
        animationDuration: getDurationFromProp(animationDuration)
      },
      actions,
      ...propGetters
    };
  }
  return getStateAndHelpers();
}
export {
  useStep
};
