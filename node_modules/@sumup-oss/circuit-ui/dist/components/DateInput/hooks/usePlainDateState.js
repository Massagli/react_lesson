"use strict";
import { useState, useEffect, useCallback } from "react";
import { Temporal } from "temporal-polyfill";
import { getTodaysDate, MAX_MONTH, MIN_MONTH, getMonthName, toPlainDate, MAX_YEAR, MIN_YEAR, MIN_DAY } from "../../../util/date.js";
import { isNumber } from "../../../util/type-check.js";
import { clamp } from "../../../util/helpers.js";
function usePlainDateState({
  value,
  defaultValue,
  onChange,
  minDate,
  maxDate,
  locale
}) {
  const [values, setValues] = useState(
    parseValue(defaultValue || value)
  );
  useEffect(() => {
    if (value) {
      setValues(parseValue(value));
    }
  }, [value]);
  const update = useCallback(
    (newValues) => {
      setValues((prevValues) => {
        const year = clampValue(
          prevValues.year,
          newValues.year,
          MIN_YEAR,
          MAX_YEAR
        );
        const month = clampValue(
          prevValues.month,
          newValues.month,
          MIN_MONTH,
          MAX_MONTH
        );
        const yearMonth2 = safePlainYearMonth(year, month);
        const maxDay = (yearMonth2 == null ? void 0 : yearMonth2.daysInMonth) || 31;
        const day = clampValue(prevValues.day, newValues.day, MIN_DAY, maxDay);
        if (onChange) {
          const plainDate = safePlainDate(year, month, day);
          onChange((plainDate == null ? void 0 : plainDate.toString()) || "");
        }
        return { year, month, day };
      });
    },
    [onChange]
  );
  const date = safePlainDate(values.year, values.month, values.day);
  const today = getTodaysDate();
  const sameYearLimit = minDate && maxDate && minDate.year === maxDate.year;
  const sameMonthLimit = sameYearLimit && minDate.month === maxDate.month;
  const currentMinYear = minDate && minDate.year === values.year;
  const currentMaxYear = maxDate && maxDate.year === values.year;
  const currentMinMonth = currentMinYear && minDate.month === values.month;
  const currentMaxMonth = currentMaxYear && maxDate.month === values.month;
  const yearMonth = safePlainYearMonth(values.year, values.month);
  const props = {
    year: {
      value: values.year,
      defaultValue: today.year,
      placeholder: "yyyy",
      step: 10,
      min: minDate ? minDate.year : 1,
      max: maxDate ? maxDate.year : 9999,
      onChange: (year) => update({ year })
    },
    month: {
      value: values.month,
      "aria-valuetext": values.month ? [values.month, getMonthName(values.month, locale)].join(", ") : "",
      defaultValue: today.month,
      placeholder: "mm",
      step: 3,
      min: sameYearLimit || currentMinYear ? minDate.month : MIN_MONTH,
      max: sameYearLimit || currentMaxYear ? maxDate.month : MAX_MONTH,
      onChange: (month) => update({ month })
    },
    day: {
      value: values.day,
      defaultValue: today.day,
      placeholder: "dd",
      step: 7,
      min: sameMonthLimit || currentMinMonth ? minDate.day : 1,
      max: sameMonthLimit || currentMaxMonth ? maxDate.day : (yearMonth == null ? void 0 : yearMonth.daysInMonth) || 31,
      onChange: (day) => update({ day })
    }
  };
  return { date, update, props };
}
function parseValue(value) {
  const plainDate = toPlainDate(value);
  if (!plainDate) {
    return { day: "", month: "", year: "" };
  }
  const { year, month, day } = plainDate;
  return { year, month, day };
}
function clampValue(prevValue, newValue, min, max) {
  if (newValue === "" || !isNumber(newValue || prevValue)) {
    return "";
  }
  return clamp(newValue || prevValue, min, max);
}
function safePlainDate(year, month, day) {
  try {
    if (isNumber(year) && isNumber(month) && isNumber(day)) {
      return new Temporal.PlainDate(year, month, day);
    }
    return void 0;
  } catch {
    return void 0;
  }
}
function safePlainYearMonth(year, month) {
  try {
    if (isNumber(year) && isNumber(month)) {
      return new Temporal.PlainYearMonth(year, month);
    }
    return void 0;
  } catch {
    return void 0;
  }
}
export {
  usePlainDateState
};
