"use strict";
"use client";
import { jsxs, jsx } from "react/jsx-runtime";
import { forwardRef, useRef, useId, useState, useEffect } from "react";
import { useFloating, offset, flip, shift, size } from "@floating-ui/react-dom";
import { Calendar } from "@sumup-oss/icons";
import { useMedia } from "../../hooks/useMedia/useMedia.js";
import { useI18n } from "../../hooks/useI18n/useI18n.js";
import { isSufficientlyLabelled, AccessibilityError } from "../../util/errors.js";
import { clsx } from "../../styles/clsx.js";
import { Calendar as Calendar$1 } from "../Calendar/Calendar.js";
import { Button } from "../Button/Button.js";
import { CloseButton } from "../CloseButton/CloseButton.js";
import { IconButton } from "../Button/IconButton.js";
import { Headline } from "../Headline/Headline.js";
import { FieldWrapper, FieldSet, FieldLegend, FieldLabelText, FieldValidationHint } from "../Field/Field.js";
import { toPlainDate } from "../../util/date.js";
import { applyMultipleRefs } from "../../util/refs.js";
import { changeInputValue } from "../../util/input-value.js";
import { Dialog } from "./components/Dialog.js";
import { DateSegment } from "./components/DateSegment.js";
import { usePlainDateState } from "./hooks/usePlainDateState.js";
import { useSegmentFocus } from "./hooks/useSegmentFocus.js";
import { getDateSegments, getCalendarButtonLabel } from "./DateInputService.js";
import classes from "./DateInput.module.css.js";
import { translations } from "./translations/index.js";
const DateInput = forwardRef(
  (props, ref) => {
    const {
      label,
      value,
      defaultValue,
      min,
      max,
      locale,
      firstDayOfWeek,
      modifiers,
      hideLabel,
      required,
      disabled,
      readOnly,
      invalid,
      hasWarning,
      showValid,
      validationHint,
      "aria-describedby": descriptionId,
      optionalLabel,
      openCalendarButtonLabel,
      closeCalendarButtonLabel,
      applyDateButtonLabel,
      clearDateButtonLabel,
      prevMonthButtonLabel,
      nextMonthButtonLabel,
      yearInputLabel,
      monthInputLabel,
      dayInputLabel,
      autoComplete,
      placement = "bottom-end",
      className,
      style,
      ...rest
    } = useI18n(props, translations);
    const isMobile = useMedia("(max-width: 479px)");
    const inputRef = useRef(null);
    const calendarButtonRef = useRef(null);
    const dialogRef = useRef(null);
    const dialogId = useId();
    const headlineId = useId();
    const validationHintId = useId();
    const descriptionIds = clsx(descriptionId, validationHintId);
    const minDate = toPlainDate(min);
    const maxDate = toPlainDate(max);
    const handleChange = (newValue) => {
      changeInputValue(inputRef.current, newValue);
    };
    const focus = useSegmentFocus();
    const state = usePlainDateState({
      value,
      defaultValue,
      onChange: handleChange,
      minDate,
      maxDate,
      locale
    });
    const [open, setOpen] = useState(false);
    const [selection, setSelection] = useState();
    const padding = 16;
    const { floatingStyles, update } = useFloating({
      open,
      placement,
      middleware: [
        offset(4),
        flip({ padding, fallbackAxisSideDirection: "start" }),
        shift({ padding }),
        size({
          padding,
          apply({ availableHeight, elements }) {
            elements.floating.style.maxHeight = `${availableHeight}px`;
          }
        })
      ],
      elements: {
        reference: calendarButtonRef.current,
        floating: dialogRef.current
      }
    });
    useEffect(() => {
      if (open) {
        update();
        window.addEventListener("resize", update);
        window.addEventListener("scroll", update);
      } else {
        window.removeEventListener("resize", update);
        window.removeEventListener("scroll", update);
      }
      return () => {
        window.removeEventListener("resize", update);
        window.removeEventListener("scroll", update);
      };
    }, [open, update]);
    const handleClick = (event) => {
      const element = event.target;
      if (element.getAttribute("role") === "spinbutton") {
        return;
      }
      focus.next();
    };
    const openCalendar = () => {
      setSelection(state.date);
      setOpen(true);
    };
    const closeCalendar = () => {
      setOpen(false);
    };
    const handleSelect = (date) => {
      setSelection(date);
      if (!isMobile) {
        const { year, month, day } = date;
        state.update({ year, month, day });
        closeCalendar();
      }
    };
    const handleApply = () => {
      if (selection) {
        const { year, month, day } = selection;
        state.update({ year, month, day });
      }
      closeCalendar();
    };
    const handleClear = () => {
      state.update({ year: "", month: "", day: "" });
      closeCalendar();
    };
    const mobileStyles = {
      position: "fixed",
      top: "auto",
      right: "0px",
      bottom: "0px",
      left: "0px"
    };
    const dialogStyles = isMobile ? mobileStyles : floatingStyles;
    const segments = getDateSegments(locale);
    const calendarButtonLabel = getCalendarButtonLabel(
      openCalendarButtonLabel,
      state.date,
      locale
    );
    if (process.env.NODE_ENV !== "production" && !isSufficientlyLabelled(label)) {
      throw new AccessibilityError(
        "DateInput",
        "The `label` prop is missing or invalid."
      );
    }
    return /* @__PURE__ */ jsxs(FieldWrapper, { disabled, className, style, children: [
      /* @__PURE__ */ jsxs(FieldSet, { "aria-describedby": descriptionIds, children: [
        /* @__PURE__ */ jsx(FieldLegend, { onClick: handleClick, children: /* @__PURE__ */ jsx(
          FieldLabelText,
          {
            label,
            hideLabel,
            required,
            optionalLabel
          }
        ) }),
        /* @__PURE__ */ jsxs("div", { className: classes.wrapper, children: [
          /* @__PURE__ */ jsx(
            "input",
            {
              type: "date",
              ref: applyMultipleRefs(ref, inputRef),
              className: classes.hidden,
              min,
              max,
              required,
              disabled,
              readOnly,
              autoComplete,
              "aria-invalid": invalid,
              "aria-hidden": "true",
              tabIndex: -1,
              value,
              defaultValue,
              ...rest
            }
          ),
          /* @__PURE__ */ jsx(
            "div",
            {
              onClick: handleClick,
              className: clsx(
                classes.segments,
                invalid && classes.invalid,
                hasWarning && classes.warning,
                readOnly && classes.readonly
              ),
              children: segments.map((segment, index) => {
                const segmentProps = {
                  required,
                  invalid,
                  disabled,
                  readOnly,
                  focus,
                  // Only the first segment should be associated with the validation hint to reduce verbosity.
                  "aria-describedby": index === 0 ? descriptionIds : void 0
                };
                switch (segment.type) {
                  case "year":
                    return /* @__PURE__ */ jsx(
                      DateSegment,
                      {
                        "aria-label": yearInputLabel,
                        autoComplete: autoComplete === "bday" ? "bday-year" : void 0,
                        ...segmentProps,
                        ...state.props.year
                      },
                      segment.type
                    );
                  case "month":
                    return /* @__PURE__ */ jsx(
                      DateSegment,
                      {
                        "aria-label": monthInputLabel,
                        autoComplete: autoComplete === "bday" ? "bday-month" : void 0,
                        ...segmentProps,
                        ...state.props.month
                      },
                      segment.type
                    );
                  case "day":
                    return /* @__PURE__ */ jsx(
                      DateSegment,
                      {
                        "aria-label": dayInputLabel,
                        autoComplete: autoComplete === "bday" ? "bday-day" : void 0,
                        ...segmentProps,
                        ...state.props.day
                      },
                      segment.type
                    );
                  case "literal":
                    return /* @__PURE__ */ jsx(
                      "div",
                      {
                        className: classes.literal,
                        "aria-hidden": "true",
                        children: segment.value
                      },
                      segment.type + index
                    );
                  default:
                    return null;
                }
              })
            }
          ),
          /* @__PURE__ */ jsx(
            IconButton,
            {
              ref: calendarButtonRef,
              type: "button",
              icon: Calendar,
              variant: "secondary",
              onClick: openCalendar,
              className: classes["calendar-button"],
              disabled: disabled || readOnly,
              "aria-expanded": open,
              "aria-haspopup": "true",
              "aria-controls": dialogId,
              children: calendarButtonLabel
            }
          )
        ] }),
        /* @__PURE__ */ jsx(
          FieldValidationHint,
          {
            id: validationHintId,
            disabled,
            invalid,
            hasWarning,
            showValid,
            validationHint
          }
        )
      ] }),
      /* @__PURE__ */ jsx(
        Dialog,
        {
          ref: dialogRef,
          id: dialogId,
          open,
          isModal: isMobile,
          onClose: closeCalendar,
          "aria-labelledby": headlineId,
          style: dialogStyles,
          children: () => /* @__PURE__ */ jsxs("div", { className: classes.content, children: [
            /* @__PURE__ */ jsxs("header", { className: classes.header, children: [
              /* @__PURE__ */ jsx(Headline, { as: "h2", size: "m", id: headlineId, children: label }),
              /* @__PURE__ */ jsx(
                CloseButton,
                {
                  size: "s",
                  variant: "tertiary",
                  onClick: closeCalendar,
                  className: classes["close-button"],
                  children: closeCalendarButtonLabel
                }
              )
            ] }),
            /* @__PURE__ */ jsx(
              Calendar$1,
              {
                className: classes.calendar,
                onSelect: handleSelect,
                selection,
                minDate,
                maxDate,
                locale,
                firstDayOfWeek,
                modifiers,
                prevMonthButtonLabel,
                nextMonthButtonLabel
              }
            ),
            (!required || isMobile) && /* @__PURE__ */ jsxs("div", { className: classes.buttons, children: [
              !required && /* @__PURE__ */ jsx(
                Button,
                {
                  type: "button",
                  variant: "tertiary",
                  onClick: handleClear,
                  children: clearDateButtonLabel
                }
              ),
              /* @__PURE__ */ jsx(
                Button,
                {
                  type: "button",
                  variant: "primary",
                  onClick: handleApply,
                  className: classes.apply,
                  children: applyDateButtonLabel
                }
              )
            ] })
          ] })
        }
      )
    ] });
  }
);
DateInput.displayName = "DateInput";
export {
  DateInput
};
