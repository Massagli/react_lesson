"use strict";
"use client";
import { jsxs, Fragment, jsx } from "react/jsx-runtime";
import { useRef, useState, useLayoutEffect } from "react";
import { isArrowLeft, isArrowRight, isBackspace, isDelete } from "../../../util/key-codes.js";
import { isNumber } from "../../../util/type-check.js";
import { shiftInRange } from "../../../util/helpers.js";
import classes from "./DateSegment.module.css.js";
function DateSegment({
  onChange,
  invalid,
  focus,
  defaultValue,
  min,
  max,
  step,
  ...props
}) {
  const sizeRef = useRef(null);
  const [width, setWidth] = useState("4ch");
  useLayoutEffect(() => {
    if (sizeRef.current) {
      const cursorWidth = 1;
      const elementSize = sizeRef.current.getBoundingClientRect();
      const elementWidth = Math.ceil(elementSize.width);
      if (elementWidth > 0) {
        setWidth(`${cursorWidth + elementWidth}px`);
      }
    }
  }, [props.value]);
  const onKeyDown = (event) => {
    const input = event.currentTarget;
    const { selectionStart, selectionEnd } = input;
    if (selectionStart === selectionEnd) {
      if (isArrowLeft(event) && (input.readOnly || selectionStart === 0)) {
        event.preventDefault();
        focus.previous();
        return;
      }
      if (isArrowRight(event) && (input.readOnly || selectionEnd === input.value.length)) {
        event.preventDefault();
        focus.next();
        return;
      }
    }
    if (!input.value) {
      if (isBackspace(event)) {
        event.preventDefault();
        focus.previous();
        return;
      }
      if (isDelete(event)) {
        event.preventDefault();
        focus.next();
        return;
      }
    }
    if (input.disabled || input.readOnly) {
      return;
    }
    const value = Number.parseInt(input.value, 10);
    let newValue;
    const getValue = (offset) => value ? shiftInRange(value, offset, min, max) : defaultValue;
    switch (event.key) {
      case "ArrowUp":
        newValue = getValue(1);
        break;
      case "ArrowDown":
        newValue = getValue(-1);
        break;
      case "PageUp":
        newValue = getValue(step);
        break;
      case "PageDown":
        newValue = getValue(-1 * step);
        break;
      case "Home":
        newValue = min;
        break;
      case "End":
        newValue = max;
        break;
      default:
        return;
    }
    if (isNumber(newValue)) {
      event.preventDefault();
      onChange(newValue);
    }
  };
  const handleChange = (event) => {
    const value = Number.parseInt(event.currentTarget.value, 10);
    onChange(value || "");
    if (value && value > Math.floor(max / 10)) {
      focus.next();
    }
  };
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(
      "input",
      {
        type: "text",
        inputMode: "numeric",
        autoCorrect: "false",
        enterKeyHint: "next",
        spellCheck: "false",
        role: "spinbutton",
        "aria-valuenow": props.value || void 0,
        "aria-valuemin": min,
        "aria-valuemax": max,
        "aria-invalid": invalid,
        className: classes.base,
        style: { ...props.style, "--width": width },
        onKeyDown,
        onChange: handleChange,
        ...focus.props,
        ...props
      }
    ),
    /* @__PURE__ */ jsx("span", { ref: sizeRef, className: classes.size, "aria-hidden": "true", children: props.value || props.placeholder })
  ] });
}
export {
  DateSegment
};
