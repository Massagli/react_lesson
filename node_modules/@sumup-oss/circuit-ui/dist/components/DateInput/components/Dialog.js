"use strict";
"use client";
import { jsxs, Fragment, jsx } from "react/jsx-runtime";
import { forwardRef, useRef, useCallback, useEffect } from "react";
import dialogPolyfill from "../../../vendor/dialog-polyfill/index.js";
import { useStackContext } from "../../StackContext/StackContext.js";
import { applyMultipleRefs } from "../../../util/refs.js";
import { clsx } from "../../../styles/clsx.js";
import { useClickOutside } from "../../../hooks/useClickOutside/useClickOutside.js";
import { useEscapeKey } from "../../../hooks/useEscapeKey/useEscapeKey.js";
import classes from "./Dialog.module.css.js";
const Dialog = forwardRef(
  ({ children, open, onClose, className, style, isModal, ...props }, ref) => {
    const zIndex = useStackContext();
    const dialogRef = useRef(null);
    const lastFocusedElementRef = useRef(null);
    const handleClickOutside = useCallback(
      // When the dialog first opens, we store the document's active element as the last active
      // element to restore focus to it when the dialog closes.
      // however, if the dialog is closed by clicking outside of it in non-modal mode,
      // we don't want to restore focus to the last active element, so we override it
      // with the element triggering the useClickOutside hook.
      (event) => {
        if (event.target instanceof HTMLElement) {
          lastFocusedElementRef.current = event.target;
        }
        onClose();
      },
      [onClose]
    );
    useClickOutside(dialogRef, handleClickOutside, open);
    useEscapeKey(onClose, open);
    const onClickListener = useCallback(
      (e) => {
        var _a;
        if (isModal && e.target === dialogRef.current) {
          (_a = dialogRef.current) == null ? void 0 : _a.close();
        }
      },
      [isModal]
    );
    useEffect(() => {
      const dialogElement = dialogRef.current;
      if (!dialogElement) {
        return void 0;
      }
      dialogPolyfill.registerDialog(dialogElement);
      dialogElement.addEventListener("close", onClose);
      dialogElement.addEventListener("click", onClickListener);
      return () => {
        dialogElement.removeEventListener("close", onClose);
        dialogElement.removeEventListener("click", onClickListener);
      };
    }, [onClose, onClickListener]);
    useEffect(() => {
      var _a;
      const dialogElement = dialogRef.current;
      if (!dialogElement) {
        return void 0;
      }
      if (open) {
        lastFocusedElementRef.current = document.activeElement;
        if (!dialogElement.open) {
          if (isModal) {
            dialogElement.showModal();
          } else {
            dialogElement.show();
          }
        }
      } else if (dialogElement.open) {
        if (lastFocusedElementRef.current && lastFocusedElementRef.current instanceof HTMLElement) {
          (_a = lastFocusedElementRef.current) == null ? void 0 : _a.focus();
        }
        dialogElement.close();
      }
      return () => {
        var _a2;
        if (dialogElement.open) {
          if (lastFocusedElementRef.current && lastFocusedElementRef.current instanceof HTMLElement) {
            (_a2 = lastFocusedElementRef.current) == null ? void 0 : _a2.focus();
          }
          dialogElement.close();
        }
      };
    }, [open, isModal]);
    return /* @__PURE__ */ jsxs(Fragment, { children: [
      /* @__PURE__ */ jsx(
        "dialog",
        {
          ref: applyMultipleRefs(ref, dialogRef),
          className: clsx(classes.dialog, className),
          style: {
            ...style,
            zIndex: zIndex || "var(--cui-z-index-modal)"
          },
          ...props,
          children: open ? children() : null
        }
      ),
      /* @__PURE__ */ jsx(
        "div",
        {
          className: classes.backdrop,
          style: {
            zIndex: `calc(${(zIndex == null ? void 0 : zIndex.toString()) || "var(--cui-z-index-modal)"} - 1)`
          }
        }
      )
    ] });
  }
);
Dialog.displayName = "Dialog";
export {
  Dialog
};
