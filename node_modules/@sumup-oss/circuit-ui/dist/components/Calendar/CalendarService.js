"use strict";
import { Temporal } from "temporal-polyfill";
import { formatDateTime } from "@sumup-oss/intl";
import { last, chunk } from "../../util/helpers.js";
import { getTodaysDate, isPlainDate, clampDate, getFirstDateOfWeek, getLastDateOfWeek } from "../../util/date.js";
var CalendarActionType = /* @__PURE__ */ ((CalendarActionType2) => {
  CalendarActionType2[CalendarActionType2["PREV_MONTH"] = 0] = "PREV_MONTH";
  CalendarActionType2[CalendarActionType2["NEXT_MONTH"] = 1] = "NEXT_MONTH";
  CalendarActionType2[CalendarActionType2["NUMBER_OF_MONTHS"] = 2] = "NUMBER_OF_MONTHS";
  CalendarActionType2[CalendarActionType2["FOCUS_DATE"] = 3] = "FOCUS_DATE";
  CalendarActionType2[CalendarActionType2["MOUSE_ENTER_DATE"] = 4] = "MOUSE_ENTER_DATE";
  CalendarActionType2[CalendarActionType2["MOUSE_LEAVE_DATE"] = 5] = "MOUSE_LEAVE_DATE";
  return CalendarActionType2;
})(CalendarActionType || {});
function initCalendar({
  selection,
  minDate,
  maxDate,
  numberOfMonths
}) {
  const today = getTodaysDate();
  let date;
  if (selection) {
    date = isPlainDate(selection) ? selection : selection.start;
  }
  const focusedDate = clampDate(date || today, minDate, maxDate);
  const hoveredDate = null;
  const months = Array.from(Array(numberOfMonths)).map(
    (_, index) => Temporal.PlainYearMonth.from(focusedDate).add({ months: index })
  );
  return { today, months, focusedDate, hoveredDate };
}
function calendarReducer(state, action) {
  switch (action.type) {
    case 0: {
      const months = state.months.map((month) => month.subtract({ months: 1 }));
      const focusedDate = isDateInMonths(state.focusedDate, months) ? state.focusedDate : state.focusedDate.subtract({ months: 1 });
      return { ...state, months, focusedDate };
    }
    case 1: {
      const months = state.months.map((month) => month.add({ months: 1 }));
      const focusedDate = isDateInMonths(state.focusedDate, months) ? state.focusedDate : state.focusedDate.add({ months: 1 });
      return { ...state, months, focusedDate };
    }
    case 2: {
      if (state.months.length === action.numberOfMonths) {
        return state;
      }
      const months = Array.from(Array(action.numberOfMonths)).map(
        (_, index) => Temporal.PlainYearMonth.from(state.focusedDate).add({ months: index })
      );
      return { ...state, months };
    }
    case 3: {
      const focusedDate = action.date;
      const months = getMonths(focusedDate, state.months);
      return { ...state, focusedDate, months };
    }
    case 4:
      return { ...state, hoveredDate: action.date };
    case 5:
      return { ...state, hoveredDate: null };
    default:
      return state;
  }
}
function getMonths(focusedDate, prevMonths) {
  const focusedMonth = Temporal.PlainYearMonth.from(focusedDate);
  if (Temporal.PlainYearMonth.compare(focusedMonth, prevMonths[0]) < 0) {
    return prevMonths.map((_, index) => focusedMonth.add({ months: index }));
  }
  if (Temporal.PlainYearMonth.compare(focusedMonth, last(prevMonths)) > 0) {
    return prevMonths.map(
      (_, index) => focusedMonth.subtract({ months: prevMonths.length - index - 1 })
    );
  }
  return prevMonths;
}
function getWeekdays(firstDayOfWeek = 1, daysInWeek = 7, locale) {
  return Array.from(Array(daysInWeek)).map((_, index) => {
    const date = new Temporal.PlainDate(1973, 1, index + firstDayOfWeek);
    return {
      narrow: formatDateTime(date, locale, {
        weekday: "narrow",
        calendar: date.calendarId
      }),
      long: formatDateTime(date, locale, {
        weekday: "long",
        calendar: date.calendarId
      })
    };
  });
}
function getMonthHeadline(yearMonth, locale) {
  const date = yearMonth.toPlainDate({ day: 1 }).withCalendar("gregory");
  return formatDateTime(date, locale, {
    year: "numeric",
    month: "long",
    calendar: date.calendarId
  });
}
function getDatesInRange(startDate, endDate) {
  const duration = { days: 1 };
  const days = [startDate];
  let current = startDate;
  while (!current.equals(endDate)) {
    current = current.add(duration);
    days.push(current);
  }
  return days;
}
function getViewOfMonth(yearMonth, firstDayOfWeek = 1, daysInWeek = 7) {
  const firstDayOfMonth = yearMonth.toPlainDate({ day: 1 });
  const lastDayOfMonth = firstDayOfMonth.add({
    days: yearMonth.daysInMonth - 1
  });
  const firstDateOfWeek = getFirstDateOfWeek(firstDayOfMonth, firstDayOfWeek);
  const lastDateOfWeek = getLastDateOfWeek(lastDayOfMonth, firstDayOfWeek);
  return chunk(getDatesInRange(firstDateOfWeek, lastDateOfWeek), daysInWeek);
}
function isDateActive(date, selection) {
  if (!selection) {
    return false;
  }
  if (isPlainDate(selection)) {
    return date.equals(selection);
  }
  if (selection.start && selection.end) {
    return Temporal.PlainDate.compare(date, selection.start) >= 0 && Temporal.PlainDate.compare(date, selection.end) <= 0;
  }
  if (selection.start) {
    return date.equals(selection.start);
  }
  return false;
}
function getSelectionType(date, hoveredDate, selection) {
  if (!selection) {
    return null;
  }
  if (isPlainDate(selection)) {
    return date.equals(selection) ? "selected" : null;
  }
  if (!selection.start && !selection.end) {
    return null;
  }
  if (selection.end || hoveredDate && Temporal.PlainDate.compare(hoveredDate, selection.start) > 0) {
    const laterDate = selection.end || hoveredDate;
    if (date.equals(selection.start) && date.equals(laterDate)) {
      return "selected";
    }
    if (date.equals(selection.start)) {
      return "range-start";
    }
    if (date.equals(laterDate)) {
      return "range-end";
    }
    if (Temporal.PlainDate.compare(date, selection.start) > 0 && Temporal.PlainDate.compare(date, laterDate) < 0) {
      return "range-middle";
    }
  }
  if (date.equals(selection.start)) {
    return "selected";
  }
  return null;
}
function isDateInMonthRange(date, minDate, maxDate) {
  if (minDate && Temporal.PlainYearMonth.compare(date, minDate) < 0 || maxDate && Temporal.PlainYearMonth.compare(date, maxDate) > 0) {
    return false;
  }
  return true;
}
function isDateInMonths(date, months) {
  return months.some((month) => month.equals(date));
}
export {
  CalendarActionType,
  calendarReducer,
  getDatesInRange,
  getMonthHeadline,
  getMonths,
  getSelectionType,
  getViewOfMonth,
  getWeekdays,
  initCalendar,
  isDateActive,
  isDateInMonthRange,
  isDateInMonths
};
