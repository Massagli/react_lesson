"use strict";
"use client";
import { jsxs, jsx } from "react/jsx-runtime";
import { forwardRef, useReducer, useEffect, useRef, useCallback, useId, useMemo } from "react";
import { Temporal } from "temporal-polyfill";
import { ArrowLeft, ArrowRight } from "@sumup-oss/icons";
import { utilClasses } from "../../styles/utility.js";
import { IconButton } from "../Button/IconButton.js";
import { Headline } from "../Headline/Headline.js";
import { clsx } from "../../styles/clsx.js";
import { getLastDateOfWeek, getFirstDateOfWeek } from "../../util/date.js";
import { CircuitError } from "../../util/errors.js";
import { applyMultipleRefs } from "../../util/refs.js";
import { useSwipe } from "../../hooks/useSwipe/useSwipe.js";
import { last } from "../../util/helpers.js";
import { Body } from "../Body/Body.js";
import { useI18n } from "../../hooks/useI18n/useI18n.js";
import { calendarReducer, initCalendar, CalendarActionType, isDateInMonthRange, getMonthHeadline, getWeekdays, getViewOfMonth, isDateActive, getSelectionType } from "./CalendarService.js";
import classes from "./Calendar.module.css.js";
import { translations } from "./translations/index.js";
const Calendar = forwardRef(
  (props, ref) => {
    const {
      selection,
      onSelect,
      onMonthsChange,
      minDate,
      maxDate,
      firstDayOfWeek = 1,
      locale,
      prevMonthButtonLabel,
      nextMonthButtonLabel,
      modifiers,
      numberOfMonths = 1,
      ...rest
    } = useI18n(props, translations);
    const [{ months, focusedDate, hoveredDate, today }, dispatch] = useReducer(
      calendarReducer,
      { selection, minDate, maxDate, numberOfMonths },
      initCalendar
    );
    useEffect(() => {
      onMonthsChange == null ? void 0 : onMonthsChange(months);
    }, [onMonthsChange, months]);
    useEffect(() => {
      dispatch({ type: CalendarActionType.NUMBER_OF_MONTHS, numberOfMonths });
    }, [numberOfMonths]);
    const calendarRef = useRef(null);
    const { daysInWeek } = focusedDate;
    const isPrevMonthDisabled = minDate ? Temporal.PlainYearMonth.compare(months[0], minDate) <= 0 : false;
    const isNextMonthDisabled = maxDate ? Temporal.PlainYearMonth.compare(last(months), maxDate) >= 0 : false;
    const touchHandlers = useSwipe((direction) => {
      if (direction === "right" && !isPrevMonthDisabled) {
        dispatch({ type: CalendarActionType.PREV_MONTH });
      }
      if (direction === "left" && !isNextMonthDisabled) {
        dispatch({ type: CalendarActionType.NEXT_MONTH });
      }
    });
    const handleFocusDate = useCallback((date) => {
      dispatch({ type: CalendarActionType.FOCUS_DATE, date });
      window.requestAnimationFrame(() => {
        var _a, _b;
        (_b = (_a = calendarRef.current) == null ? void 0 : _a.querySelector('button[tabindex="0"]')) == null ? void 0 : _b.focus();
      });
    }, []);
    const handleKeyDown = useCallback(
      (event) => {
        let nextFocusedDate;
        switch (event.key) {
          case "ArrowRight":
            nextFocusedDate = focusedDate.add({ days: 1 });
            break;
          case "ArrowLeft":
            nextFocusedDate = focusedDate.subtract({ days: 1 });
            break;
          case "ArrowDown":
            nextFocusedDate = focusedDate.add({ days: focusedDate.daysInWeek });
            break;
          case "ArrowUp":
            nextFocusedDate = focusedDate.subtract({
              days: focusedDate.daysInWeek
            });
            break;
          case "PageUp":
            nextFocusedDate = focusedDate.subtract(
              event.shiftKey ? { years: 1 } : { months: 1 }
            );
            break;
          case "PageDown":
            nextFocusedDate = focusedDate.add(
              event.shiftKey ? { years: 1 } : { months: 1 }
            );
            break;
          case "Home":
            nextFocusedDate = getFirstDateOfWeek(focusedDate, firstDayOfWeek);
            break;
          case "End":
            nextFocusedDate = getLastDateOfWeek(focusedDate, firstDayOfWeek);
            break;
          default:
            return;
        }
        event.preventDefault();
        if (isDateInMonthRange(nextFocusedDate, minDate, maxDate)) {
          handleFocusDate(nextFocusedDate);
        }
      },
      [handleFocusDate, focusedDate, minDate, maxDate, firstDayOfWeek]
    );
    const handleMouseEnter = useCallback((date) => {
      dispatch({ type: CalendarActionType.MOUSE_ENTER_DATE, date });
    }, []);
    const handleMouseLeave = useCallback(() => {
      dispatch({ type: CalendarActionType.MOUSE_LEAVE_DATE });
    }, []);
    if (process.env.NODE_ENV !== "production" && modifiers) {
      Object.keys(modifiers).forEach((key) => {
        try {
          Temporal.PlainDate.from(key);
        } catch (_error) {
          throw new CircuitError(
            "Calendar",
            `The "${key}" key of the \`modifiers\` prop is not a valid ISO 8601 date string.`
          );
        }
      });
    }
    return /* @__PURE__ */ jsxs("div", { ref: applyMultipleRefs(ref, calendarRef), role: "group", ...rest, children: [
      /* @__PURE__ */ jsxs("div", { className: classes.header, children: [
        /* @__PURE__ */ jsx("div", { className: classes.prev, children: /* @__PURE__ */ jsx(
          IconButton,
          {
            type: "button",
            icon: ArrowLeft,
            size: "s",
            variant: "tertiary",
            disabled: isPrevMonthDisabled,
            onClick: () => {
              dispatch({ type: CalendarActionType.PREV_MONTH });
            },
            children: prevMonthButtonLabel
          }
        ) }),
        /* @__PURE__ */ jsx("div", { className: classes.next, children: /* @__PURE__ */ jsx(
          IconButton,
          {
            type: "button",
            icon: ArrowRight,
            size: "s",
            variant: "tertiary",
            disabled: isNextMonthDisabled,
            onClick: () => {
              dispatch({ type: CalendarActionType.NEXT_MONTH });
            },
            children: nextMonthButtonLabel
          }
        ) })
      ] }),
      /* @__PURE__ */ jsx("div", { className: classes.months, children: months.map((month) => /* @__PURE__ */ jsx(
        Month,
        {
          yearMonth: month,
          selection,
          focusedDate,
          hoveredDate,
          minDate,
          maxDate,
          today,
          firstDayOfWeek,
          daysInWeek,
          locale,
          modifiers,
          onFocus: handleFocusDate,
          onSelect,
          onKeyDown: handleKeyDown,
          onMouseEnter: handleMouseEnter,
          onMouseLeave: handleMouseLeave,
          ...touchHandlers
        },
        month.toString()
      )) })
    ] });
  }
);
Calendar.displayName = "Calendar";
function Month({
  yearMonth,
  selection,
  focusedDate,
  hoveredDate,
  minDate,
  maxDate,
  today,
  modifiers = {},
  onFocus,
  onSelect,
  onKeyDown,
  onMouseEnter,
  onMouseLeave,
  firstDayOfWeek = 1,
  daysInWeek,
  locale
}) {
  const descriptionIds = useId();
  const headlineId = useId();
  const headline = useMemo(
    () => getMonthHeadline(yearMonth, locale),
    [yearMonth, locale]
  );
  const weekdays = useMemo(
    () => getWeekdays(firstDayOfWeek, daysInWeek, locale),
    [firstDayOfWeek, daysInWeek, locale]
  );
  const weeks = useMemo(
    () => getViewOfMonth(yearMonth, firstDayOfWeek, daysInWeek),
    [yearMonth, firstDayOfWeek, daysInWeek]
  );
  return /* @__PURE__ */ jsxs(
    "div",
    {
      className: classes.month,
      style: { "--calendar-days-in-week": daysInWeek },
      children: [
        /* @__PURE__ */ jsx(
          Headline,
          {
            as: "h2",
            size: "s",
            id: headlineId,
            "aria-live": "polite",
            "aria-atomic": "true",
            className: classes.headline,
            children: headline
          }
        ),
        /* @__PURE__ */ jsxs("table", { role: "grid", className: classes.grid, children: [
          /* @__PURE__ */ jsx("thead", { children: /* @__PURE__ */ jsx("tr", { children: weekdays.map((weekday) => /* @__PURE__ */ jsxs("th", { scope: "col", children: [
            /* @__PURE__ */ jsx("span", { className: utilClasses.hideVisually, children: weekday.long }),
            /* @__PURE__ */ jsx(
              Body,
              {
                as: "span",
                weight: "semibold",
                "aria-hidden": "true",
                className: classes.weekday,
                children: weekday.narrow
              }
            )
          ] }, weekday.long)) }) }),
          /* @__PURE__ */ jsx("tbody", { children: weeks.map((week) => /* @__PURE__ */ jsx("tr", { children: week.map((date) => {
            const isoDate = date.toString();
            const descriptionId = `${descriptionIds}-${isoDate}`;
            const isOutsideMonth = !yearMonth.equals(date);
            if (isOutsideMonth) {
              return /* @__PURE__ */ jsx("td", {}, isoDate);
            }
            const { disabled, description } = modifiers[isoDate] || {};
            const isActive = isDateActive(date, selection);
            const isToday = date.equals(today);
            const isFirstDay = date.day === 1;
            const isLastDay = date.day === date.daysInMonth;
            const isFocused = date.equals(focusedDate);
            const isDisabled = disabled || minDate && Temporal.PlainDate.compare(date, minDate) < 0 || maxDate && Temporal.PlainDate.compare(date, maxDate) > 0;
            const selectionType = getSelectionType(
              date,
              hoveredDate,
              selection
            );
            const handleClick = (event) => {
              if (isDisabled) {
                event.preventDefault();
                event.stopPropagation();
                event.nativeEvent.stopImmediatePropagation();
              } else {
                onSelect == null ? void 0 : onSelect(date);
              }
              onFocus(date);
            };
            const handleMouseEnter = () => {
              if (!isDisabled) {
                onMouseEnter(date);
              }
            };
            return /* @__PURE__ */ jsxs("td", { children: [
              /* @__PURE__ */ jsx(
                "button",
                {
                  type: "button",
                  "data-date": isoDate,
                  onClick: handleClick,
                  onMouseEnter: handleMouseEnter,
                  onMouseLeave,
                  onKeyDown,
                  className: clsx(
                    classes.day,
                    selectionType && classes[selectionType],
                    isFirstDay && classes["first-day"],
                    isLastDay && classes["last-day"],
                    utilClasses.focusVisible
                  ),
                  tabIndex: isFocused ? 0 : -1,
                  ...isToday && { "aria-current": "date" },
                  ...isActive && { "aria-pressed": "true" },
                  ...isDisabled && { "aria-disabled": "true" },
                  ...description && {
                    "aria-describedby": descriptionId
                  },
                  children: date.day
                }
              ),
              description && /* @__PURE__ */ jsx(
                "span",
                {
                  id: descriptionId,
                  className: clsx(utilClasses.hideVisually),
                  children: description
                }
              )
            ] }, isoDate);
          }) }, week.toString())) })
        ] })
      ]
    }
  );
}
export {
  Calendar
};
