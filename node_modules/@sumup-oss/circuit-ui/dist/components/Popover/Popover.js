"use strict";
"use client";
import { jsxs, jsx } from "react/jsx-runtime";
import { useRef, useId, useCallback, useEffect, Fragment } from "react";
import { useFloating, offset, flip, size } from "@floating-ui/react-dom";
import { isArrowDown, isArrowUp } from "../../util/key-codes.js";
import { isFunction } from "../../util/type-check.js";
import { clsx } from "../../styles/clsx.js";
import { sharedClasses } from "../../styles/shared.js";
import classes from "./Popover.module.css.js";
import { useStackContext } from "../StackContext/StackContext.js";
import { useFocusList } from "../../hooks/useFocusList/useFocusList.js";
import { usePrevious } from "../../hooks/usePrevious/usePrevious.js";
import { useMedia } from "../../hooks/useMedia/useMedia.js";
import { useEscapeKey } from "../../hooks/useEscapeKey/useEscapeKey.js";
import { useClickOutside } from "../../hooks/useClickOutside/useClickOutside.js";
import { Portal } from "../Portal/Portal.js";
import { Hr } from "../Hr/Hr.js";
import { useComponents } from "../ComponentsContext/useComponents.js";
const PopoverItem = ({
  children,
  icon: Icon,
  destructive,
  className,
  ...props
}) => {
  const { Link } = useComponents();
  const Element = props.href ? Link : "button";
  return /* @__PURE__ */ jsxs(
    Element,
    {
      className: clsx(
        classes.item,
        sharedClasses.listItem,
        destructive && sharedClasses.listItemDestructive,
        className
      ),
      ...props,
      children: [
        Icon && /* @__PURE__ */ jsx(Icon, { className: classes.icon, size: "24", "aria-hidden": "true" }),
        children
      ]
    }
  );
};
function isDivider(action) {
  return "type" in action && action.type === "divider";
}
const sizeOptions = {
  apply({ availableHeight, elements }) {
    elements.floating.style.setProperty(
      "--popover-max-height",
      `${availableHeight}px`
    );
  }
};
const Popover = ({
  isOpen = false,
  onToggle,
  actions,
  placement = "bottom",
  fallbackPlacements = ["top", "right", "left"],
  component: Component,
  offset: offset$1,
  className,
  role = "menu",
  ...props
}) => {
  const zIndex = useStackContext();
  const triggerKey = useRef(null);
  const menuEl = useRef(null);
  const triggerId = useId();
  const menuId = useId();
  const { x, y, strategy, refs, update } = useFloating({
    open: isOpen,
    placement,
    strategy: "fixed",
    middleware: offset$1 ? [
      offset(offset$1),
      flip({ fallbackPlacements }),
      size(sizeOptions)
    ] : [flip({ fallbackPlacements }), size(sizeOptions)]
  });
  const focusProps = useFocusList();
  const prevOpen = usePrevious(isOpen);
  const isMobile = useMedia("(max-width: 479px)");
  const mobileStyles = {
    position: "fixed",
    bottom: "0px",
    left: "0px",
    right: "0px",
    width: "auto",
    zIndex: zIndex || "var(--cui-z-index-popover)"
  };
  const handleToggle = useCallback(
    (state) => {
      onToggle((prev) => isFunction(state) ? state(prev) : state);
    },
    [onToggle]
  );
  const handleTriggerClick = useCallback(() => {
    handleToggle((prev) => !prev);
  }, [handleToggle]);
  const handleTriggerKeyDown = useCallback(
    (event) => {
      if (isArrowDown(event)) {
        triggerKey.current = "ArrowDown";
        handleToggle(true);
      }
      if (isArrowUp(event)) {
        triggerKey.current = "ArrowUp";
        handleToggle((prev) => !prev);
      }
    },
    [handleToggle]
  );
  const handlePopoverItemClick = (onClick) => (event) => {
    onClick == null ? void 0 : onClick(event);
    handleToggle(false);
  };
  useEscapeKey(() => handleToggle(false), isOpen);
  useClickOutside(
    [refs.reference, refs.floating],
    () => handleToggle(false),
    isOpen
  );
  useEffect(() => {
    if (isOpen) {
      update();
      window.addEventListener("resize", update);
      window.addEventListener("scroll", update);
    } else {
      window.removeEventListener("resize", update);
      window.removeEventListener("scroll", update);
    }
    return () => {
      window.removeEventListener("resize", update);
      window.removeEventListener("scroll", update);
    };
  }, [isOpen, update]);
  useEffect(() => {
    var _a, _b, _c;
    if (!prevOpen && isOpen) {
      const element = triggerKey.current && triggerKey.current === "ArrowUp" ? (_a = menuEl.current) == null ? void 0 : _a.lastElementChild : (_b = menuEl.current) == null ? void 0 : _b.firstElementChild;
      if (element) {
        element.focus();
      }
    }
    if (prevOpen && !isOpen) {
      const triggerButton = (_c = refs.reference.current) == null ? void 0 : _c.firstElementChild;
      triggerButton.focus();
    }
    triggerKey.current = null;
  }, [isOpen, prevOpen, refs.reference]);
  const isMenu = role === "menu";
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx("div", { className: classes.trigger, ref: refs.setReference, children: /* @__PURE__ */ jsx(
      Component,
      {
        id: triggerId,
        "aria-controls": menuId,
        "aria-expanded": isOpen,
        onClick: handleTriggerClick,
        onKeyDown: handleTriggerKeyDown
      }
    ) }),
    /* @__PURE__ */ jsxs(Portal, { children: [
      /* @__PURE__ */ jsx(
        "div",
        {
          className: clsx(classes.overlay, isOpen && classes.open),
          style: { zIndex: zIndex || "var(--cui-z-index-popover)" }
        }
      ),
      /* @__PURE__ */ jsx(
        "div",
        {
          ...props,
          ref: refs.setFloating,
          className: clsx(classes.wrapper, isOpen && classes.open, className),
          style: isMobile ? mobileStyles : {
            position: strategy,
            top: y,
            left: x,
            zIndex: zIndex || "var(--cui-z-index-popover)"
          },
          children: /* @__PURE__ */ jsx(
            "div",
            {
              id: menuId,
              ref: menuEl,
              "aria-labelledby": isMenu ? triggerId : void 0,
              role: isMenu ? "menu" : void 0,
              className: clsx(classes.menu, isOpen && classes.open),
              children: actions.map(
                (action, index) => isDivider(action) ? /* @__PURE__ */ jsx(Hr, { className: classes.divider }, index) : /* @__PURE__ */ jsx(
                  PopoverItem,
                  {
                    ...action,
                    ...focusProps,
                    role: isMenu ? "menuitem" : void 0,
                    onClick: handlePopoverItemClick(action.onClick)
                  },
                  index
                )
              )
            }
          )
        }
      )
    ] })
  ] });
};
export {
  Popover,
  PopoverItem
};
