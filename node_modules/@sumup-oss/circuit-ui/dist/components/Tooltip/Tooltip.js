"use strict";
"use client";
import { jsxs, jsx } from "react/jsx-runtime";
import { forwardRef, useId, useRef, useCallback, useEffect, Fragment } from "react";
import { useFloating, flip, shift, arrow } from "@floating-ui/react-dom";
import { atom } from "nanostores";
import { useStore } from "@nanostores/react";
import { clsx } from "../../styles/clsx.js";
import { applyMultipleRefs } from "../../util/refs.js";
import { CircuitError, isSufficientlyLabelled, AccessibilityError } from "../../util/errors.js";
import classes from "./Tooltip.module.css.js";
import { useEscapeKey } from "../../hooks/useEscapeKey/useEscapeKey.js";
const $activeTooltipId = atom("initial");
function getState(activeTooltipId, tooltipId) {
  switch (activeTooltipId) {
    case "initial": {
      return "initial";
    }
    case tooltipId: {
      return "open";
    }
    default: {
      return "closed";
    }
  }
}
const Tooltip = forwardRef(
  ({
    label,
    component: Component,
    type,
    placement: defaultPlacement = "top",
    className,
    style,
    ...props
  }, ref) => {
    var _a, _b;
    const activeTooltipId = useStore($activeTooltipId);
    const tooltipId = useId();
    const arrowRef = useRef(null);
    const state = getState(activeTooltipId, tooltipId);
    const ariaAttributeName = type === "label" ? "aria-labelledby" : "aria-describedby";
    const handleOpen = useCallback(() => {
      $activeTooltipId.set(tooltipId);
    }, [tooltipId]);
    const handleClose = useCallback(() => {
      $activeTooltipId.set(null);
    }, []);
    const handleFocus = useCallback(
      (event) => {
        if (
          // Vitest and Jest use nwsapi to mock the `Element.matches` API.
          // It has a bug where `:focus-visible` is not matched unless
          // the element has the `autofocus` property set.
          // https://github.com/dperini/nwsapi/issues/122
          process.env.NODE_ENV === "test" ? event.currentTarget.matches(":focus") : event.currentTarget.matches(":focus-visible")
        ) {
          handleOpen();
        }
      },
      [handleOpen]
    );
    useEffect(() => {
      $activeTooltipId.set(null);
    }, []);
    useEscapeKey(
      handleClose,
      state === "open"
      /* open */
    );
    const { refs, floatingStyles, middlewareData, update, placement } = useFloating({
      open: state === "open",
      placement: defaultPlacement,
      middleware: [
        flip(),
        shift({ padding: 4 }),
        arrow({
          element: arrowRef,
          // This accounts for the content's border radius
          padding: 8
        })
      ]
    });
    useEffect(() => {
      const selector = `[${ariaAttributeName}="${tooltipId}"]`;
      const referenceElement = document.querySelector(selector);
      refs.setReference(referenceElement);
    });
    useEffect(() => {
      if (state === "open") {
        update();
        window.addEventListener("resize", update);
        window.addEventListener("scroll", update);
        return () => {
          window.removeEventListener("resize", update);
          window.removeEventListener("scroll", update);
        };
      }
      window.removeEventListener("resize", update);
      window.removeEventListener("scroll", update);
      return void 0;
    }, [state, update]);
    if (process.env.NODE_ENV !== "production") {
      if (!type) {
        throw new CircuitError("Tooltip", "The `type` prop is required.");
      }
      if (!isSufficientlyLabelled(label)) {
        throw new AccessibilityError(
          "Tooltip",
          "The `label` prop is missing or invalid."
        );
      }
    }
    const referenceProps = { [ariaAttributeName]: tooltipId };
    const side = placement.split("-")[0];
    return /* @__PURE__ */ jsxs(Fragment, { children: [
      /* @__PURE__ */ jsx(
        Component,
        {
          ...referenceProps,
          onFocus: handleFocus,
          onBlur: handleClose,
          onMouseEnter: handleOpen,
          onMouseLeave: handleClose,
          className: classes.component
        }
      ),
      /* @__PURE__ */ jsxs(
        "div",
        {
          ...props,
          ref: applyMultipleRefs(ref, refs.setFloating),
          id: tooltipId,
          role: "tooltip",
          onMouseEnter: handleOpen,
          onMouseLeave: handleClose,
          "data-state": state,
          "data-side": side,
          className: clsx(classes.base, className),
          style: state === "initial" ? style : { ...style, ...floatingStyles },
          children: [
            /* @__PURE__ */ jsx("div", { className: classes.content, children: label }),
            /* @__PURE__ */ jsx(
              "div",
              {
                ref: arrowRef,
                className: classes.arrow,
                style: {
                  top: (_a = middlewareData.arrow) == null ? void 0 : _a.y,
                  left: (_b = middlewareData.arrow) == null ? void 0 : _b.x
                }
              }
            )
          ]
        }
      )
    ] });
  }
);
Tooltip.displayName = "Tooltip";
export {
  Tooltip
};
