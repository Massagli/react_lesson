"use strict";
"use client";
import { jsxs } from "react/jsx-runtime";
import { useCallback, useEffect, useMemo, createContext, createElement } from "react";
import ReactModal from "react-modal";
import { last } from "../../util/helpers.js";
import { warn } from "../../util/logger.js";
import classes from "./ModalContext.module.css.js";
import { useStack } from "../../hooks/useStack/useStack.js";
const PORTAL_CLASS_NAME = classes.portal;
const HTML_OPEN_CLASS_NAME = classes.open;
const APP_ELEMENT_IDS = ["root", "__next", "__docusaurus", "storybook-root"];
function getAppElement() {
  for (const id of APP_ELEMENT_IDS) {
    const element = document.getElementById(id);
    if (element) {
      return element;
    }
  }
  return null;
}
if (typeof window !== "undefined") {
  const appElement = getAppElement();
  if (appElement) {
    ReactModal.setAppElement(appElement);
  } else if (process.env.NODE_ENV !== "production" && process.env.NODE_ENV !== "test") {
    warn(
      "ModalProvider",
      "Could not find the app root element to hide it when a modal is open.",
      "Add an element with the id `#root` at the root of your application."
    );
  }
}
const ModalContext = createContext({
  setModal: () => {
  },
  removeModal: () => {
  }
});
function ModalProvider({
  children,
  initialState,
  ...defaultModalProps
}) {
  const [modals, dispatch] = useStack(initialState);
  const setModal = useCallback(
    (modal) => {
      dispatch({ type: "push", item: modal });
    },
    [dispatch]
  );
  const removeModal = useCallback(
    (modal) => {
      if (modal.onClose) {
        modal.onClose();
      }
      dispatch({
        type: "remove",
        id: modal.id,
        transition: {
          duration: modal.component.TRANSITION_DURATION
        }
      });
    },
    [dispatch]
  );
  const activeModal = last(modals);
  useEffect(() => {
    const cleanUp = () => {
      var _a;
      document.documentElement.classList.remove(HTML_OPEN_CLASS_NAME);
      (_a = getAppElement()) == null ? void 0 : _a.removeAttribute("aria-hidden");
    };
    if (!activeModal) {
      cleanUp();
      return void 0;
    }
    const popModal = () => {
      removeModal(activeModal);
    };
    window.addEventListener("popstate", popModal);
    return () => {
      cleanUp();
      window.removeEventListener("popstate", popModal);
    };
  }, [activeModal, removeModal]);
  const context = useMemo(
    () => ({ setModal, removeModal }),
    [setModal, removeModal]
  );
  return /* @__PURE__ */ jsxs(ModalContext.Provider, { value: context, children: [
    children,
    modals.map((modal) => {
      const {
        id,
        onClose,
        transition,
        component: Component,
        ...modalProps
      } = modal;
      return (
        // @ts-expect-error The props are enforced by the modal hooks,
        // so this warning can be safely ignored.
        /* @__PURE__ */ createElement(
          Component,
          {
            ...defaultModalProps,
            ...modalProps,
            key: id,
            isOpen: !transition,
            onClose: () => removeModal(modal),
            portalClassName: PORTAL_CLASS_NAME,
            htmlOpenClassName: HTML_OPEN_CLASS_NAME,
            bodyOpenClassName: ""
          }
        )
      );
    })
  ] });
}
export {
  ModalContext,
  ModalProvider
};
