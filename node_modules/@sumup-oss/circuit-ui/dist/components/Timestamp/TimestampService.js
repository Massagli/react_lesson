"use strict";
import { Temporal } from "temporal-polyfill";
import { formatDateTime, isRelativeTimeFormatSupported, formatRelativeTime } from "@sumup-oss/intl";
const DATE_STYLE_MAP = {
  long: "long",
  short: "medium",
  narrow: "short"
};
const TIME_STYLE = "short";
const UNITS = [
  {
    name: "years",
    duration: Temporal.Duration.from("P1Y"),
    interval: 3e5
    // 5 minutes
  },
  {
    name: "months",
    duration: Temporal.Duration.from("P1M"),
    interval: 3e5
    // 5 minutes
  },
  {
    name: "weeks",
    duration: Temporal.Duration.from("P1W"),
    interval: 3e5
    // 5 minutes
  },
  {
    name: "days",
    duration: Temporal.Duration.from("P1D"),
    interval: 3e5
    // 5 minutes
  },
  {
    name: "hours",
    duration: Temporal.Duration.from("PT1H"),
    interval: 6e4
    // 1 minute
  },
  {
    name: "minutes",
    duration: Temporal.Duration.from("PT1M"),
    interval: 5e3
    // 5 seconds
  },
  {
    name: "seconds",
    duration: Temporal.Duration.from("PT1S"),
    interval: 1e3
    // 1 second
  }
];
function getInitialState({
  datetime,
  locale,
  formatStyle,
  includeTime
}) {
  const zonedDateTime = Temporal.ZonedDateTime.from(datetime);
  const options = {
    dateStyle: DATE_STYLE_MAP[formatStyle]
  };
  if (includeTime) {
    options.timeStyle = TIME_STYLE;
  }
  return {
    label: formatDateTime(zonedDateTime.toPlainDateTime(), locale, options),
    interval: null
  };
}
function getState({
  datetime,
  locale,
  formatStyle,
  variant,
  includeTime
}) {
  const zonedDateTime = Temporal.ZonedDateTime.from(datetime);
  const now = Temporal.Now.zonedDateTimeISO();
  const duration = zonedDateTime.since(now);
  const isBeyondThreshold = Temporal.Duration.compare(duration.abs(), Temporal.Duration.from("P1M"), {
    relativeTo: now
  }) > 0;
  if (variant === "absolute" || variant === "auto" && isBeyondThreshold || !isRelativeTimeFormatSupported) {
    const options2 = {
      dateStyle: DATE_STYLE_MAP[formatStyle]
    };
    if (includeTime) {
      options2.timeStyle = TIME_STYLE;
    }
    return {
      label: formatDateTime(zonedDateTime.toPlainDateTime(), locale, options2),
      interval: null
    };
  }
  const bestUnitIndex = UNITS.findIndex(
    (unit2) => Temporal.Duration.compare(duration.abs(), unit2.duration, {
      relativeTo: now
    }) >= 0
  );
  const unitIndex = bestUnitIndex >= 0 ? bestUnitIndex : UNITS.length - 1;
  const unit = UNITS[unitIndex];
  const value = duration.round({
    smallestUnit: unit.name,
    relativeTo: now
  })[unit.name];
  const options = { style: formatStyle };
  return {
    label: formatRelativeTime(value, unit.name, locale, options),
    interval: unit.interval
  };
}
export {
  getInitialState,
  getState
};
