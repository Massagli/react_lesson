#!/usr/bin/env node
"use strict";
/**
 * Copyright 2023, SumUp Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateTokens = validateTokens;
exports.createCSSCustomProperties = createCSSCustomProperties;
exports.createFontFaceDeclarations = createFontFaceDeclarations;
const node_fs_1 = __importDefault(require("node:fs"));
const node_path_1 = __importDefault(require("node:path"));
const browserslist_1 = __importDefault(require("browserslist"));
const lightningcss_1 = require("lightningcss");
const schema_js_1 = require("../themes/schema.js");
const shared_js_1 = require("../themes/shared.js");
const light_js_1 = require("../themes/light.js");
const dark_js_1 = require("../themes/dark.js");
const fonts_js_1 = require("../themes/fonts.js");
function main() {
    const files = {
        'light': [
            {
                type: 'tokens',
                tokens: [...light_js_1.light, ...shared_js_1.shared],
                selectors: [':root'],
                colorScheme: 'light',
            },
        ],
        'dark': [
            {
                type: 'tokens',
                tokens: [...dark_js_1.dark, ...shared_js_1.shared],
                selectors: [':root'],
                colorScheme: 'dark',
            },
        ],
        'light-scoped': [
            {
                type: 'tokens',
                tokens: light_js_1.light,
                selectors: ['[data-color-scheme="light"]'],
                colorScheme: 'light',
            },
        ],
        'dark-scoped': [
            {
                type: 'tokens',
                tokens: dark_js_1.dark,
                selectors: ['[data-color-scheme="dark"]'],
                colorScheme: 'dark',
            },
        ],
        'dynamic': [
            {
                type: 'tokens',
                tokens: [...light_js_1.light, ...shared_js_1.shared],
                selectors: [':root'],
                colorScheme: 'light',
            },
            {
                type: 'tokens',
                tokens: dark_js_1.dark,
                selectors: ['@media (prefers-color-scheme: dark)', ':root'],
                colorScheme: 'dark',
            },
            {
                type: 'tokens',
                tokens: light_js_1.light,
                selectors: ['[data-color-scheme="light"]'],
                colorScheme: 'light',
            },
            {
                type: 'tokens',
                tokens: dark_js_1.dark,
                selectors: ['[data-color-scheme="dark"]'],
                colorScheme: 'dark',
            },
        ],
        'fonts': [
            {
                type: 'font-faces',
                fontFaces: fonts_js_1.inter,
            },
        ],
    };
    const targets = (0, lightningcss_1.browserslistToTargets)((0, browserslist_1.default)());
    Object.entries(files).forEach(([name, configs]) => {
        const filename = `${name}.css`;
        const filepath = node_path_1.default.join(__dirname, '../', filename);
        const styles = configs
            .map((config) => {
            switch (config.type) {
                case 'tokens': {
                    validateTokens(config.tokens);
                    return createCSSCustomProperties(config);
                }
                case 'font-faces': {
                    return createFontFaceDeclarations(config);
                }
                default: {
                    throw new Error('Unsupported config type');
                }
            }
        })
            .join('\n');
        const { code } = (0, lightningcss_1.transform)({
            filename,
            code: Buffer.from(styles),
            targets,
        });
        node_fs_1.default.writeFileSync(filepath, code, { flag: 'w' });
    });
}
/**
 * Validates that the token values match the expected type.
 */
function validateTokens(tokens) {
    tokens.forEach(({ name, type }) => {
        const token = schema_js_1.schema.find((t) => t.name === name);
        if (!token) {
            return;
        }
        if (token.type !== type) {
            throw new Error([
                `The "${name}" token does not match the expected type.`,
                `Expected "${token.type}". Received "${type}."`,
            ].join(' '));
        }
    });
}
/**
 * Generates CSS custom properties from the tokens
 */
function createCSSCustomProperties(config) {
    const selectorStart = config.selectors
        .map((selector) => `${selector} {`)
        .join('');
    const selectorEnd = config.selectors.map(() => '}').join('');
    const customProperties = config.tokens
        .flatMap((token) => {
        const { description, name, value } = token;
        const lines = [];
        if (description) {
            lines.push(`/* ${description} */`);
        }
        lines.push(`${name}: ${value.toString()};`);
        return lines;
    })
        .join(' ');
    return `${selectorStart}
    color-scheme: ${config.colorScheme};
    ${customProperties}
  ${selectorEnd}`;
}
/**
 * Generates font face declarations from the font faces
 */
function createFontFaceDeclarations(config) {
    return config.fontFaces
        .map((fontFace) => {
        const properties = Object.entries(fontFace)
            .map(([name, value]) => `${name}: ${value};`)
            .join('');
        return `@font-face { ${properties} }`;
    })
        .join(' ');
}
try {
    main();
}
catch (error) {
    console.error(error.message);
    process.exit(1);
}
